// This source file was auto-generated by ClassMate++
// Created: 17 Aug 2019 3:42:21 pm
// Copyright (c) 2019, HurleyWorks

#include "berserkpch.h"
#include "NanoguiLayer.h"

using namespace nanogui;

// ctor
NanoguiLayer::NanoguiLayer (GLFWwindow* window, const PropertyService& properties)
	: RenderLayer(properties),
	  window(window)
{	

	initGraph(&fpsGraph, GRAPH_RENDER_FPS, "Frame Time");
	initGraph(&cpuGraph, GRAPH_RENDER_MS, "CPU Time");
	initGraph(&gpuGraph, GRAPH_RENDER_MS, "GPU Time");
	initGPUTimer(&gpuTimer);

	init();
}

// dtor
NanoguiLayer::~NanoguiLayer ()
{	
}

void NanoguiLayer::init()
{
	Screen::initialize(window, false);

	Screen::drawAll();
	setVisible(true);
}

void NanoguiLayer::onUpdate()
{
	drawContents();
	drawWidgets();
}

void NanoguiLayer::onInput(const InputEvent& input)
{
	switch (input.getType())
	{
		case InputEvent::Press:
			Screen::mouseButtonCallbackEvent(input.getButton(), MOUSE_PRESS, 0);
			//LOG(DBUG) << "PRESS";
			break;

		case InputEvent::Release:
			Screen::mouseButtonCallbackEvent(input.getButton(), MOUSE_RELEASE, 0);
			//LOG(DBUG) << "RELEASE";
			break;

		case InputEvent::Move:
			Screen::cursorPosCallbackEvent((float)input.getX(), (float)input.getY());
			//LOG(DBUG) << "MOVE";
			break;

		case InputEvent::Drag:
			Screen::cursorPosCallbackEvent((float)input.getX(), (float)input.getY());
			//LOG(DBUG) << "DRAG";
			break;
	}
}

// postInfoMessage
void NanoguiLayer::postInfoMessage(const std::string& title, const std::string& msg)
{
	auto dlg = new MessageDialog(this, MessageDialog::Type::Information, title, msg);
	dlg->setCallback([](int result)
		{

		});
}

// postWarningMessage
void NanoguiLayer::postWarningMessage(const std::string& title, const std::string& msg)
{
	auto dlg = new MessageDialog(this, MessageDialog::Type::Warning, title, msg);
	dlg->setCallback([](int result)
		{

		});
}

// postQuestiongMessage
void NanoguiLayer::postQuestiongMessage(const std::string& title, const std::string& msg)
{
	auto dlg = new MessageDialog(this, MessageDialog::Type::Warning, title, msg, "Yes", "No", true);
	dlg->setCallback([](int result)
		{

		});
}

void NanoguiLayer::drawPerformanceGraph(NVGcontext* const ctx)
{
	double t, dt;
	float gpuTimes[3];

	t = glfwGetTime();
	dt = t - previousTime;
	previousTime = t;

	startGPUTimer(&gpuTimer);

	int x = size().x() - 400;
	if (x < 5) x = 5;
	int y = size().y() - 35;
	renderGraph(ctx, x, y, &fpsGraph);
	renderGraph(ctx, x + 200 + 5, y, &cpuGraph);
	if (gpuTimer.supported)
		renderGraph(ctx, x + 200 + 5 + 200 + 5, y, &gpuGraph);

	// Measure the CPU time taken excluding swap buffers (as the swap may wait for GPU)
	cpuTime = glfwGetTime() - t;
	updateGraph(&fpsGraph, dt);
	updateGraph(&cpuGraph, cpuTime);

	// We may get multiple results.
	int n = stopGPUTimer(&gpuTimer, gpuTimes, 3);
	for (int i = 0; i < n; i++)
		updateGraph(&gpuGraph, gpuTimes[i]);
}
