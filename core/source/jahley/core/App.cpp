// This source file was auto-generated by ClassMate++
// Created: 26 Jan 2019 8:47:47 pm
// Copyright (c) 2019, HurleyWorks

#include "berserkpch.h"
#include "App.h"

namespace Jahley
{

	// ctor
	App::App (DesktopWindowSettings settings, bool windowApp)
		: windowApp(windowApp),
		  errorCallback(std::bind(&App::onFatalError, this, std::placeholders::_1)),
		  preCrashCallback(std::bind(&App::preCrash, this)),
		  log(errorCallback, preCrashCallback),
		  refreshTime(settings.refreshRate)
	{	
		
		if (windowApp)
		{
			try
			{
				bgColor = settings.bgColor;
				window = std::make_unique<OpenglWindow>(input);
				window->create(Vector2i(settings.width, settings.height), settings.name);
			}
			catch (std::exception& e)
			{
				LOG(CRITICAL) << e.what();
			}
			catch (...)
			{
				LOG(CRITICAL) << "Caught unknown exception!";
			}
		}
	}

	// dtor
	App::~App ()
	{	
	
	}

	void App::run()
	{
		while (input.windowIsOpen())
		{
			window->renderBegin(bgColor);

			// let the client update
			update();

			window->renderEnd(true); // true means glfw will wait for events instead of polling

			// post an empty event to GLFW
			std::this_thread::sleep_for(refreshTime);
			glfwPostEmptyEvent();
		}

		window.reset();
	}

	// preCrash
	void App::preCrash()
	{
		
#if (defined(WIN32) || defined(_WIN32) || defined(__WIN32__))
		__debugbreak();
#endif
	}

	// onFatalError
	void App::onFatalError(g3::FatalMessagePtr fatal_message)
	{
		LOG(WARNING) << fatal_message.get()->toString();

		// now ready to exit, instead of reinventing the wheel we do it the g3log way
		g3::internal::pushFatalMessageToLogger(fatal_message);
	}
}