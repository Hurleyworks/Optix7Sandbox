// This source file was auto-generated by ClassMate++
// Created: 26 Jan 2019 8:47:47 pm
// Copyright (c) 2019, HurleyWorks

#include "berserkpch.h"
#include "App.h"

namespace Jahley
{
	// ctor
	App::App (DesktopWindowSettings settings, bool windowApp)
		: windowApp(windowApp),
		  errorCallback(std::bind(&App::onFatalError, this, std::placeholders::_1)),
		  preCrashCallback(std::bind(&App::preCrash, this)),
		  log(errorCallback, preCrashCallback),
		  refreshTime(settings.refreshRate)
	{	
		if (windowApp)
		{
			try
			{
				bgColor = settings.bgColor;
				window = std::make_unique<OpenglWindow>(input);
				window->create(Vector2i(settings.width, settings.height), settings.name);

				// broadcast InputHandler events to the render layers
				connect(input, &InputHandler::onEvent, *this, &App::onInputEvent);
			}
			catch (std::exception& e)
			{
				LOG(CRITICAL) << e.what();
			}
			catch (...)
			{
				LOG(CRITICAL) << "Caught unknown exception!";
			}
		}
	}

	// dtor
	App::~App ()
	{	
	
	}

	void App::run()
	{
		// let the client initialize
		onInit();

		while (input.windowIsOpen())
		{
			window->renderBegin(bgColor);

			for (RenderLayerRef layer : layers)
				layer->onUpdate();

			// let the client update
			update();

			window->renderEnd(true); // true means glfw will wait for events instead of polling

			// post an empty event to GLFW
			std::this_thread::sleep_for(refreshTime);
			glfwPostEmptyEvent();
		}

		window.reset();
	}

	void App::pushLayer(RenderLayerRef layer, bool attach)
	{
		layers.pushLayer(layer);
	}

	void App::pushOverlay(RenderLayerRef layer, bool attach)
	{
		layers.pushOverlay(layer);
	}

	void App::onInputEvent(const InputEvent & e)
	{
		for (RenderLayerRef layer : layers)
			layer->onInput(e);
	}

	// preCrash
	void App::preCrash()
	{
		
#if (defined(WIN32) || defined(_WIN32) || defined(__WIN32__))
		__debugbreak();
#endif
	}

	// onFatalError
	void App::onFatalError(g3::FatalMessagePtr fatal_message)
	{
		LOG(WARNING) << fatal_message.get()->toString();

		// now ready to exit, instead of reinventing the wheel we do it the g3log way
		g3::internal::pushFatalMessageToLogger(fatal_message);
	}
}