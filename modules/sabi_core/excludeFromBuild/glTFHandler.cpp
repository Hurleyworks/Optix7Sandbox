
// This source file was auto-generated by ClassMate++
// Created: 11 Sep 2019 6:50:03 pm
// Copyright (c) 2019, HurleyWorks

using sabi::PixelBuffer;
using sabi::PixelBufferHandle;

void glTFLoader::loadGeometry(const std::string& path, LoadMeshCallback meshCallback)
{
	ScopedStopWatch sw(_FN_);

	filePath = path;
	this->meshCallback = meshCallback;

	tinygltf::TinyGLTF loader;
	std::string err;
	std::string warn;

	bool ret = loader.LoadASCIIFromFile(&model, &err, &warn, path);

	if (!warn.empty())
		LOG(WARNING) << warn.c_str();

	if (!err.empty())
		LOG(CRITICAL) << err.c_str();

	if (!ret)
		throw std::runtime_error("Failed to parse glTF: " + path);

	processNodes();
}

void glTFLoader::loadAll(const std::string& path, LoadImagesCallback imageCallback, LoadMeshCallback meshCallback)
{
	ScopedStopWatch sw(_FN_);

	filePath = path;
	
	this->meshCallback = meshCallback;
	this->imageCallback = imageCallback;

	tinygltf::TinyGLTF loader;
	std::string err;
	std::string warn;

	bool ret = loader.LoadASCIIFromFile(&model, &err, &warn, path);

	if (!warn.empty())
		LOG(WARNING) << warn.c_str();

	if (!err.empty())
		LOG(CRITICAL) << err.c_str();

	if (!ret)
		throw std::runtime_error("Failed to parse glTF: " + path);

	processImages();
	processNodes();
}

void glTFLoader::getTextureCoords_0(const Node& node, const int32_t accessorIndex, MeshBuffersHandle& m)
{
	const auto& accessor = model.accessors[accessorIndex];
	const auto& bufferView = model.bufferViews[accessor.bufferView];
	const auto& buffer = model.buffers[bufferView.buffer];
	const size_t bufferOffset = bufferView.byteOffset + accessor.byteOffset;

	//specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.
	int componentCount = 1;
	if (accessor.type != TINYGLTF_TYPE_SCALAR)
	{
		componentCount = accessor.type;

		bool sizeOK = componentCount > 0 && componentCount < 5;
	}

	int uvCount = accessor.count;
	VertexMapRef vmap = VertexMap::create();
	vmap->dim = componentCount;
	vmap->type = VertexMapType::UV;
	vmap->values.resize(componentCount, uvCount);

	std::memcpy(vmap->values.data(), &buffer.data.at(bufferOffset), vmap->values.size() * sizeof(float));
	m->vmaps.insert(std::make_pair("UV", vmap));
}

void glTFLoader::getNormals(const Node& node, const int32_t accessorIndex, MeshBuffersHandle& m)
{
	const auto& accessor = model.accessors[accessorIndex];
	const auto& bufferView = model.bufferViews[accessor.bufferView];
	const auto& buffer = model.buffers[bufferView.buffer];
	const size_t bufferOffset = bufferView.byteOffset + accessor.byteOffset;

	//specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.
	int componentCount = 1;
	if (accessor.type != TINYGLTF_TYPE_SCALAR)
	{
		componentCount = accessor.type;

		bool sizeOK = componentCount > 0 && componentCount < 5;
	}

	int normalCount = accessor.count;
	m->N.resize(componentCount, normalCount);
	
	std::memcpy(m->N.data(), &buffer.data.at(bufferOffset), m->N.size() * sizeof(float));
}

void glTFLoader::getVertices(const Node& node, const int32_t accessorIndex, MeshBuffersHandle& m)
{
	const auto& accessor = model.accessors[accessorIndex];
	const auto& bufferView = model.bufferViews[accessor.bufferView];
	const auto& buffer = model.buffers[bufferView.buffer];
	const size_t bufferOffset = bufferView.byteOffset + accessor.byteOffset;

	//specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.
	int componentCount = 1;
	if (accessor.type != TINYGLTF_TYPE_SCALAR)
	{
		componentCount = accessor.type;

		bool sizeOK = componentCount > 0 && componentCount < 5;
		CHECK(sizeOK);
	}

	int vertexCount = accessor.count;
	m->V.resize(componentCount, vertexCount);
	
	std::memcpy(m->V.data(), &buffer.data.at(bufferOffset), m->V.size() * sizeof(float));
}

void glTFLoader::getIndices(const Node& node, const int32_t accessorIndex, MeshBuffersHandle& m)
{
	const auto& accessor = model.accessors[accessorIndex];
	const auto& bufferView = model.bufferViews[accessor.bufferView];
	const auto& buffer = model.buffers[bufferView.buffer];
	const size_t bufferOffset = bufferView.byteOffset + accessor.byteOffset;

	uint32_t numberOfIndices = static_cast<uint32_t>(accessor.count);

	const int32_t sizeofElement =
		accessor.componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT ? 2 :
		accessor.componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT ? 4 :
		accessor.componentType == TINYGLTF_COMPONENT_TYPE_FLOAT ? 4 :
		0;

	int componentCount = 3;

	// why is the accessor type for indices a scalar instead of a vector?
	if (accessor.type != TINYGLTF_TYPE_SCALAR)
	{
		componentCount = accessor.type;

		bool sizeOK = componentCount > 0 && componentCount < 5;
	}

	int triangleCount = numberOfIndices / componentCount;
	
	MatrixXus F;
	F.resize(componentCount, triangleCount);
	std::memcpy(F.data(), &buffer.data.at(bufferOffset), F.size() * sizeofElement);

	Surface s;
	s.indices() = F.cast<uint32_t>();
	m->S.push_back(s);
}

void glTFLoader::processNodes()
{
	std::vector<int32_t> root_nodes(model.nodes.size(), 1);
	for (auto& gltf_node : model.nodes)
	{
		for (int32_t child : gltf_node.children)
		{
			LOG(DBUG) << child;
			root_nodes[child] = 0;
		}
	}
		
	for (size_t i = 0; i < root_nodes.size(); ++i)
	{
		if (!root_nodes[i])
			continue;

		auto& node = model.nodes[i];

		if (node.mesh != INVALID_INDEX)
		{
			processMesh( node, model.meshes[node.mesh], meshCallback);
		}

	    if (!node.children.empty())
		{
			for (int32_t child : node.children)
			{
				auto& node = model.nodes[child];
				if (node.mesh != INVALID_INDEX)
				{
					processMesh(node,  model.meshes[node.mesh], meshCallback);
				}
			}
		}
	}
}

void glTFLoader::processImages()
{
	Images images;

	for (const auto& gltf_image : model.images)
	{
		std::cerr << "Processing image '" << gltf_image.name << "'\n"
			<< "\t(" << gltf_image.width << "x" << gltf_image.height << ")x" << gltf_image.component << "\n"
			<< "\tbits: " << gltf_image.bits << std::endl;

		assert(gltf_image.component == 4);
		assert(gltf_image.bits == 8 || gltf_image.bits == 16);


		PixelBufferHandle buffer = PixelBuffer::createHandle();

		buffer->spec.width = gltf_image.width;
		buffer->spec.height = gltf_image.height;
		buffer->spec.channels = gltf_image.component;

		if (gltf_image.bits == 8)
		{
			buffer->uint8Pixels.resize(buffer->spec.channels, buffer->getPixelCount());

			std::memcpy(buffer->uint8Pixels.data(), gltf_image.image.data(), buffer->byteCountUint8());

			images.push_back(std::move(buffer));
		}
	}

	imageCallback(std::move(images));
}

void glTFLoader::processMesh(Node& node, Mesh& mesh, LoadMeshCallback meshCallback)
{
	for (auto& primitive : mesh.primitives)
	{
		if (primitive.mode != TINYGLTF_MODE_TRIANGLES) // Ignore non-triangle meshes
		{
			LOG(CRITICAL) << "Not a triangle mesh!";
			continue;
		}

		MeshBuffersHandle m = std::make_shared<MeshBuffers>();
		getIndices(node, primitive.indices, m);

		for (auto& attrib : primitive.attributes)
		{
			if (attrib.first.compare("POSITION") == 0)
			{
				getVertices(node, attrib.second, m);
			}

			if (attrib.first.compare("NORMAL") == 0)
			{
				getNormals(node, attrib.second, m);
			}

			if (attrib.first.compare("TEXCOORD_0") == 0)
			{
				getTextureCoords_0(node, attrib.second, m);
			}
		}

		meshCallback(m, filePath);
	}

}

