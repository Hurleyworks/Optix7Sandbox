
// This source file was auto-generated by ClassMate++
// Created: 11 Sep 2019 6:50:03 pm
// Copyright (c) 2019, HurleyWorks

#include <glad/glad.h>
#include "glTFHandler.h"

using sabi::PixelBuffer;
using sabi::PixelBufferHandle;
using sabi::TextureHandlerRef;
using sabi::Material;
using sabi::Vector4d;

void glTFLoader::load(const std::string& path, LoadMeshCallback meshCallback)
{
	ScopedStopWatch sw(_FN_);

	filePath = path;
	this->meshCallback = meshCallback;

	// must clear containers because we're using the same model on every call
	reset();

	tinygltf::TinyGLTF loader;
	std::string err;
	std::string warn;

	bool ret = loader.LoadASCIIFromFile(&model, &err, &warn, path);

	if (!warn.empty())
		LOG(WARNING) << warn.c_str();

	if (!err.empty())
		LOG(CRITICAL) << err.c_str();

	if (!ret)
		throw std::runtime_error("Failed to parse glTF: " + path);


	processImages();
	processTextures();
	processMaterials();
	processNodes();
}

void glTFLoader::loadGeometry(const std::string& path, LoadMeshCallback meshCallback)
{
	ScopedStopWatch sw(_FN_);

	filePath = path;
	this->meshCallback = meshCallback;

	tinygltf::TinyGLTF loader;
	std::string err;
	std::string warn;

	bool ret = loader.LoadASCIIFromFile(&model, &err, &warn, path);

	if (!warn.empty())
		LOG(WARNING) << warn.c_str();

	if (!err.empty())
		LOG(CRITICAL) << err.c_str();

	if (!ret)
		throw std::runtime_error("Failed to parse glTF: " + path);

	processNodes();
}


void glTFLoader::getTextureCoords_0(const Node& node, const int32_t accessorIndex, MeshBuffersHandle& m)
{
	const auto& accessor = model.accessors[accessorIndex];
	const auto& bufferView = model.bufferViews[accessor.bufferView];
	const auto& buffer = model.buffers[bufferView.buffer];
	const size_t bufferOffset = bufferView.byteOffset + accessor.byteOffset;

	//specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.
	int componentCount = 1;
	if (accessor.type != TINYGLTF_TYPE_SCALAR)
	{
		componentCount = accessor.type;

		bool sizeOK = componentCount > 0 && componentCount < 5;
	}

	int uvCount = accessor.count;
	VertexMapRef vmap = VertexMap::create();
	vmap->dim = componentCount;
	vmap->type = VertexMapType::UV;
	vmap->values.resize(componentCount, uvCount);

	std::memcpy(vmap->values.data(), &buffer.data.at(bufferOffset), vmap->values.size() * sizeof(float));
	m->vmaps.insert(std::make_pair("UV", vmap));
}

void glTFLoader::getNormals(const Node& node, const int32_t accessorIndex, MeshBuffersHandle& m)
{
	const auto& accessor = model.accessors[accessorIndex];
	const auto& bufferView = model.bufferViews[accessor.bufferView];
	const auto& buffer = model.buffers[bufferView.buffer];
	const size_t bufferOffset = bufferView.byteOffset + accessor.byteOffset;

	//specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.
	int componentCount = 1;
	if (accessor.type != TINYGLTF_TYPE_SCALAR)
	{
		componentCount = accessor.type;

		bool sizeOK = componentCount > 0 && componentCount < 5;
	}

	int normalCount = accessor.count;
	m->N.resize(componentCount, normalCount);
	
	std::memcpy(m->N.data(), &buffer.data.at(bufferOffset), m->N.size() * sizeof(float));
}

void glTFLoader::getVertices(const Node& node, const int32_t accessorIndex, MeshBuffersHandle& m)
{
	const auto& accessor = model.accessors[accessorIndex];
	const auto& bufferView = model.bufferViews[accessor.bufferView];
	const auto& buffer = model.buffers[bufferView.buffer];
	const size_t bufferOffset = bufferView.byteOffset + accessor.byteOffset;

	//specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4.
	int componentCount = 1;
	if (accessor.type != TINYGLTF_TYPE_SCALAR)
	{
		componentCount = accessor.type;

		bool sizeOK = componentCount > 0 && componentCount < 5;
		CHECK(sizeOK);
	}

	int vertexCount = accessor.count;
	m->V.resize(componentCount, vertexCount);
	
	std::memcpy(m->V.data(), &buffer.data.at(bufferOffset), m->V.size() * sizeof(float));
}

void glTFLoader::getIndices(const Node& node, const int32_t accessorIndex, MeshBuffersHandle& m, int materialIndex)
{
	const auto& accessor = model.accessors[accessorIndex];
	const auto& bufferView = model.bufferViews[accessor.bufferView];
	const auto& buffer = model.buffers[bufferView.buffer];
	const size_t bufferOffset = bufferView.byteOffset + accessor.byteOffset;

	uint32_t numberOfIndices = static_cast<uint32_t>(accessor.count);

	const int32_t sizeofElement =
		accessor.componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT ? 2 :
		accessor.componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT ? 4 :
		accessor.componentType == TINYGLTF_COMPONENT_TYPE_FLOAT ? 4 :
		0;

	int componentCount = 3;

	// why is the accessor type for indices a scalar instead of a vector?
	if (accessor.type != TINYGLTF_TYPE_SCALAR)
	{
		componentCount = accessor.type;

		bool sizeOK = componentCount > 0 && componentCount < 5;
	}

	int triangleCount = numberOfIndices / componentCount;
	
	MatrixXus F;
	F.resize(componentCount, triangleCount);
	std::memcpy(F.data(), &buffer.data.at(bufferOffset), F.size() * sizeofElement);

	Surface s;
	s.indices() = F.cast<uint32_t>();
	if (materials.size() && materialIndex >= 0 && materialIndex < materials.size())
	{
		s.setMaterail(materials[materialIndex]);
	}
	
	m->S.push_back(s);
}

void glTFLoader::reset()
{
	// must reset containers because we're using the same Model every time!
	model.accessors.clear();
	model.animations.clear();
	model.buffers.clear();
	model.bufferViews.clear();
	model.materials.clear();
	model.meshes.clear();
	model.nodes.clear();
	model.textures.clear();
	model.images.clear();
	model.skins.clear();
	model.samplers.clear();
	model.cameras.clear();
	model.scenes.clear();
	model.lights.clear();

	materials.clear();
	textures.clear();
	images.clear();
}

void glTFLoader::processNodes()
{
	std::vector<int32_t> root_nodes(model.nodes.size(), 1);
	for (auto& gltf_node : model.nodes)
	{
		for (int32_t child : gltf_node.children)
		{
			LOG(DBUG) << child;
			root_nodes[child] = 0;
		}
	}
		
	for (size_t i = 0; i < root_nodes.size(); ++i)
	{
		if (!root_nodes[i])
			continue;

		auto& node = model.nodes[i];

		if (node.mesh != INVALID_INDEX)
		{
			processMesh( node, model.meshes[node.mesh], meshCallback);
		}

	    if (!node.children.empty())
		{
			for (int32_t child : node.children)
			{
				auto& node = model.nodes[child];
				if (node.mesh != INVALID_INDEX)
				{
					processMesh(node,  model.meshes[node.mesh], meshCallback);
				}
			}
		}
	}
}

void glTFLoader::processImages()
{
	for (const auto& gltf_image : model.images)
	{
		std::cerr << "Processing image '" << gltf_image.name << "'\n"
			<< "\t(" << gltf_image.width << "x" << gltf_image.height << ")x" << gltf_image.component << "\n"
			<< "\tbits: " << gltf_image.bits << std::endl;

		assert(gltf_image.component == 4);
		assert(gltf_image.bits == 8 || gltf_image.bits == 16);


		PixelBufferHandle buffer = PixelBuffer::createHandle();

		buffer->spec.width = gltf_image.width;
		buffer->spec.height = gltf_image.height;
		buffer->spec.channels = gltf_image.component;

		if (gltf_image.bits == 8)
		{
			buffer->uint8Pixels.resize(buffer->spec.channels, buffer->getPixelCount());

			std::memcpy(buffer->uint8Pixels.data(), gltf_image.image.data(), buffer->byteCountUint8());

			images.push_back(std::move(buffer));
		}
	}

//	imageCallback(std::move(images));
}

void glTFLoader::processTextures()
{
	
	for (const auto& gltf_texture : model.textures)
	{
		TextureHandlerRef texture = TextureHandler::create();

		if (gltf_texture.sampler == -1)
		{
			TextureSampler sampler;
			sampler.imageIndex = gltf_texture.source;
			auto it = images.begin();
			std::advance(it, sampler.imageIndex);
			if (it != images.end())
				texture->addTextureImage(*it);
			texture->addTextureSampler(sampler); 
			textures.push_back(texture);
			//scene.addSampler(cudaAddressModeWrap, cudaAddressModeWrap, cudaFilterModeLinear, gltf_texture.source);
			continue;
		}

		const auto& gltf_sampler = model.samplers[gltf_texture.sampler];
		TextureSampler sampler;
		sampler.wrapS = gltf_sampler.wrapS == GL_CLAMP_TO_EDGE ? TextureMode::clamp :
			gltf_sampler.wrapS == GL_MIRRORED_REPEAT ? TextureMode::mirror :
			TextureMode::wrap;
		sampler.wrapS = gltf_sampler.wrapT == GL_CLAMP_TO_EDGE ? TextureMode::clamp :
			gltf_sampler.wrapT == GL_MIRRORED_REPEAT ? TextureMode::mirror :
			TextureMode::wrap;
		sampler.filter = gltf_sampler.minFilter == GL_NEAREST ? TextureFilterMode::point :
			TextureFilterMode::linear;
		
		sampler.imageIndex = gltf_texture.source;
		auto it = images.begin();
		std::advance(it, sampler.imageIndex);
		if (it != images.end())
			texture->addTextureImage(*it);
		texture->addTextureSampler(sampler);

		textures.push_back(texture);
	}

	//textureCallback(std::move(textures));
}

void glTFLoader::processMaterials()
{
	for (auto& gltf_material : model.materials)
	{
		LOG(DBUG) << "Processing glTF material: '" << gltf_material.name;
		
		Material material;
		{
			const auto base_color_it = gltf_material.values.find("baseColorFactor");
			if (base_color_it != gltf_material.values.end())
			{
				const tinygltf::ColorValue c = base_color_it->second.ColorFactor();
				material.base_color = Vector4d(c[0], c[1], c[2], c[3]).cast<float>();
				wabi::vecStr4f(material.base_color, DBUG, "BASE_COLOR");
			}
			else
			{
				LOG(DBUG) << "Using default base color factor";
			}
		}

		{
			const auto base_color_it = gltf_material.values.find("baseColorTexture");
			if (base_color_it != gltf_material.values.end())
			{
				LOG(DBUG) << "Found base color tex: " << base_color_it->second.TextureIndex();
				material.base_color_tex = textures[base_color_it->second.TextureIndex()];
			}
			else
			{
				LOG(DBUG) << "No base color tex";
			}
		}

		{
			const auto roughness_it = gltf_material.values.find("roughnessFactor");
			if (roughness_it != gltf_material.values.end())
			{
				material.roughness = static_cast<float>(roughness_it->second.Factor());
				LOG(DBUG) << "Rougness:  " << material.roughness;
			}
			else
			{
				LOG(DBUG) << "Using default roughness factor";
			}
		}

		{
			const auto metallic_it = gltf_material.values.find("metallicFactor");
			if (metallic_it != gltf_material.values.end())
			{
				material.metallic = static_cast<float>(metallic_it->second.Factor());
				LOG(DBUG) << "Metallic:  " << material.metallic;
			}
			else
			{
				LOG(DBUG) << "Using default metallic factor";
			}
		}

		{
			const auto metallic_roughness_it = gltf_material.values.find("metallicRoughnessTexture");
			if (metallic_roughness_it != gltf_material.values.end())
			{
				LOG(DBUG) << "Found metallic roughness texture: " << metallic_roughness_it->second.TextureIndex();
				material.metallic_roughness_tex = textures[metallic_roughness_it->second.TextureIndex()];
			}
			else
			{
				LOG(DBUG) << "No metallic roughness texture";
			}
		}

		{
			const auto normal_it = gltf_material.additionalValues.find("normalTexture");
			if (normal_it != gltf_material.additionalValues.end())
			{
				LOG(DBUG) << "Found normal color texture: " << normal_it->second.TextureIndex();
				material.normal_tex = textures[normal_it->second.TextureIndex()];
			}
			else
			{
				LOG(DBUG) << "No normal texture";
			}
		}

		materials.push_back(material);
	}
}

void glTFLoader::processMesh(Node& node, Mesh& mesh, LoadMeshCallback meshCallback)
{
	for (auto& primitive : mesh.primitives)
	{
		if (primitive.mode != TINYGLTF_MODE_TRIANGLES) // Ignore non-triangle meshes
		{
			LOG(CRITICAL) << "Not a triangle mesh!";
			continue;
		}

		LOG(DBUG) << "Material index: " << primitive.material;

		MeshBuffersHandle m = std::make_shared<MeshBuffers>();
		getIndices(node, primitive.indices, m, primitive.material);
		

		for (auto& attrib : primitive.attributes)
		{
			if (attrib.first.compare("POSITION") == 0)
			{
				getVertices(node, attrib.second, m);
			}

			if (attrib.first.compare("NORMAL") == 0)
			{
				getNormals(node, attrib.second, m);
			}

			if (attrib.first.compare("TEXCOORD_0") == 0)
			{
				getTextureCoords_0(node, attrib.second, m);
			}
		}

		meshCallback(m, filePath);
	}

}

