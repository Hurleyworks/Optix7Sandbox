#include "MeshOps.h"

// This source file was auto-generated by ClassMate++
// Created: 20 Feb 2019 5:01:44 pm
// Copyright (c) 2019, HurleyWorks

using namespace wabi;
using namespace Eigen;
using juce::numElementsInArray;

MeshBuffersHandle MeshOps::buildTriMeshFromArrays(const float vertices[], int pointCount, const unsigned indices[][3], int triCount)
{
	MeshBuffersHandle m = std::make_shared<MeshBuffers>();

	m->V.resize(3, pointCount);
	std::memcpy(m->V.data(), vertices, pointCount * 3 * sizeof(float));

	Surface s;
	MatrixXu & tris = s.indices();
	tris.resize(3, triCount);
	std::memcpy(tris.data(), indices, triCount * 3 * sizeof(unsigned int));

	m->S.push_back(s);

	return m;
}

MeshBuffersHandle MeshOps::createPrimitiveMesh(PrimitiveType primitive)
{
	int pointCount = 0;
	int triCount = 0;
	
	switch (primitive)
	{
		case PrimitiveType::Ball:
			pointCount = numElementsInArray(BallVertices);
			pointCount /= 3;
			triCount = numElementsInArray(BallIndices);
			return MeshOps::buildTriMeshFromArrays(BallVertices, pointCount, BallIndices, triCount);

		case PrimitiveType::Box:
			pointCount = numElementsInArray(BoxVertices);
			pointCount /= 3;
			triCount = numElementsInArray(BoxIndices);
			return MeshOps::buildTriMeshFromArrays(BoxVertices, pointCount, BoxIndices, triCount);

		case PrimitiveType::Cylinder:
			pointCount = numElementsInArray(CylinderVertices);
			pointCount /= 3;
			triCount = numElementsInArray(CylinderIndices);
			return MeshOps::buildTriMeshFromArrays(CylinderVertices, pointCount, CylinderIndices, triCount);

		case PrimitiveType::Capsule:
			pointCount = numElementsInArray(CapsuleVertices);
			pointCount /= 3;
			triCount = numElementsInArray(CapsuleIndices);
			return MeshOps::buildTriMeshFromArrays(CapsuleVertices, pointCount, CapsuleIndices, triCount);
			
		case PrimitiveType::Torus:
			pointCount = numElementsInArray(gVerticesTorus);
			pointCount /= 3;
			triCount = numElementsInArray(gIndicesTorus);
			return MeshOps::buildTriMeshFromArrays(gVerticesTorus, pointCount, gIndicesTorus, triCount);
			
		case PrimitiveType::Bunny:
			pointCount = numElementsInArray(gVerticesBunny);
			pointCount /= 3;
			triCount = numElementsInArray(gIndicesBunny);
			return MeshOps::buildTriMeshFromArrays(gVerticesBunny, pointCount, gIndicesBunny, triCount);
			break;

		case PrimitiveType::Nozzle:
			pointCount = numElementsInArray(SquirtGunVertices);
			pointCount /= 3;
			triCount = numElementsInArray(SquirtGunIndices);
			MeshOps::buildTriMeshFromArrays(SquirtGunVertices, pointCount, SquirtGunIndices, triCount);

		default:
			return nullptr;
	}

	return nullptr;
}

void MeshOps::centerVertices(MeshBuffersHandle mesh, const AlignedBox3f& modelBound, float scale)
{
	int pointCount = mesh->V.cols();
	Vector3f center = modelBound.center();
	for (int i = 0; i < pointCount; i++)
	{
		Vector3f pnt = mesh->V.col(i);
		pnt -= center;
		pnt *= scale;
		mesh->V.col(i) = pnt;
	}
}

void MeshOps::normalizeSize(MeshBuffersHandle mesh, const AlignedBox3f& modelBound, float& scale)
{
	Eigen::Vector3f offset = modelBound.center();
	Eigen::Vector3f edges = modelBound.max() - modelBound.min();
	float maxEdge = std::max(edges.x(), std::max(edges.y(), edges.z()));
	scale = 1.0f / maxEdge;  // max 
}
