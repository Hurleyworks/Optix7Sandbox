// This header file was auto-generated by ClassMate++
// Created: 29 Dec 2018 1:52:03 pm
// Copyright (c) 2018, HurleyWorks

#pragma  once

// From Design Patterns book:

// The choice of internal representation for the scene affects nearly
// every aspect of the framework's design. All editing, formatting, displaying 
// and analysis will require traversing this representation. The way we organize 
// this information will impact the design of the rest of the application

// Composite Pattern
//   Compose objects into tree structures to represent part - whole hierarchies. 
//   Composite lets clients treat individual objecta and compositions of objects uniformily


using RenderableNode = std::shared_ptr<class Renderable>;
using RenderableWeakRef = std::weak_ptr<class Renderable>;
using RenderableMap = std::unordered_map<ItemID, RenderableNode>;
using WeakRenderableMap = std::unordered_map<ItemID, RenderableWeakRef>;
using RenderableList = std::vector< RenderableNode>;
using WeakRenderableList = std::vector< RenderableWeakRef>;

class Renderable : public std::enable_shared_from_this<Renderable>,
				   protected Noncopyable,
				   public HasId
{

public:
	RenderableNode getPtr() { return shared_from_this(); }

public:
	virtual ~Renderable() { LOG(DBUG) << getName() << "::" << getID(); }

	const ItemID getID() const { return id(); }
	const BodyID getClientID() const { return clientID; }
	void setClientID(BodyID bodyID) { clientID = bodyID; }

	const std::string & getName() const { return name; }
	void setName(const std::string & name) { this->name = name; }

	const RenderableDesc & description() const { return desc; }
	RenderableDesc & description() { return desc; }
	void setDescription(const RenderableDesc & description) { desc = description; }

	const RenderableState & getState() const { return state; }
	RenderableState & getState() { return state; }
	void setState(RenderableState state) { this->state = state; }

	MeshBuffersHandle getMesh() const { return mesh; }
	void setMesh(MeshBuffersHandle mesh) { this->mesh = mesh; }
	size_t getTriangleCount() const {return mesh ? mesh->triangleCount() : 0;}

	SpaceTime & getSpaceTime() { return spacetime; }
	const SpaceTime & getSpaceTime() const { return spacetime; }
	void setSpacetime(const SpaceTime & spacetime) { this->spacetime = spacetime; }

	void debug(const std::string & msg)
	{
		LOG(DBUG) << msg << "::" << getName() << "::" << getID() << "::" << getPtr().use_count();
	}

	virtual const RenderableData getData() const
	{
		RenderableData d;
		d.clientID = clientID;
		d.desc = desc;
		d.mesh = mesh;
		d.name = name;
		d.sceneID = id();
		d.spacetime = spacetime;
		d.state = state;

		return d;
	}


	virtual void addChild(RenderableNode node) {}
	virtual bool hasChild(RenderableNode node) const { return false; }
	virtual RenderableNode findChild(ItemID key) { return nullptr; }
	virtual RenderableNode createClone(RenderableNode source) { return nullptr; }
	virtual RenderableNode createInstance() { return nullptr; }
	virtual void setInstancedFrom(RenderableNode & node) {}
	virtual RenderableNode getInstancedFrom() { return nullptr; }
	virtual bool isInstance() const { return false; }
	virtual size_t getNumberOfInstances() const { return 0; }

	virtual void removeChild(RenderableNode node) {}
	virtual void removeChildren() {}
	
	void setParent(RenderableNode node) { parent = RenderableWeakRef(node); }
	RenderableNode getParent() const { return parent.lock(); }

	const RenderableMap & getChildren() const { return children; }
	RenderableMap & getChildren()  { return children; }

	template <class T>
	std::shared_ptr<T> getParent() const
	{
		return std::dynamic_pointer_cast<T>(parent.lock());
	}

	void * getUserdata() { return userdata; }
	void setUserData(void * data) { userdata = data; }

	//friend class WorldOps;

 protected:
	Renderable() {  }

	RenderableWeakRef parent;
	
	RenderableMap children;

	// a renderable item has a location in spacetime
	SpaceTime spacetime;

	// a renderable might have matter
	MeshBuffersHandle mesh = nullptr;

	// a renderable has a description
	RenderableDesc desc;

	// a renderable has a state
	RenderableState state;

	// might have a client side id
	BodyID clientID = INVALID_ID;

	// a renderable has a nmae
	std::string name = "unnamed";

	// can I do this with templates somewhow?
	void * userdata = nullptr;

};

