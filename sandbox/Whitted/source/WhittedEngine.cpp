
// This source file was auto-generated by ClassMate++
// Created: 18 Aug 2019 4:00:14 pm
// Copyright (c) 2019, HurleyWorks

#include "WhittedEngine.h"

using juce::String;
using juce::File;
using juce::StringArray;
using mace::FileServices;
using Eigen::Vector4f;
using Eigen::Vector3f;

// the bulk of this code is from the Optix7 optixWhitted sample

// ctor
WhittedEngine::WhittedEngine (const PropertyService& properties, const OptixConfig& config)
	: OptixEngine(properties, config)
{	
	
}

// dtor
WhittedEngine::~WhittedEngine ()
{	
	try
	{
		

		// context is destroyed automatically in OptixEngine destructor
	}
	catch (std::exception& e)
	{
		LOG(CRITICAL) << e.what();
	}
	catch (...)
	{
		LOG(CRITICAL) << "Caught unknown exception";
	}
}

void WhittedEngine::init(CameraHandle& camera)
{
	//renderer.init(camera->getScreenWidth(), camera->getScreenHeight());
	output_buffer.init(CUDAOutputBufferType::ZERO_COPY, camera->getScreenWidth(), camera->getScreenHeight());
	
	state.context = context->get();
	state.params.width = camera->getScreenWidth();
	state.params.height = camera->getScreenHeight();

	createGeomety();
	createPipeline();
	createSBT();
	initLaunchParams();

	output_buffer.setStream(state.stream);
}


std::string WhittedEngine::getPtxString(const std::string& name)
{
	std::string resourceFolder = properties.renderProps->getVal<std::string>(RenderKey::ResourceFolder);
	File f(resourceFolder);
	if (!f.exists())
		throw std::runtime_error("No resource folder found at " + resourceFolder);

	String ptxFolder = resourceFolder + "/ptx";
	StringArray ptxFiles;
	String wildCard("*.ptx");
	FileServices::getFiles(ptxFolder, ptxFiles, wildCard);

	String ptxStr = String::empty;

	for (auto ptx : ptxFiles)
	{
		File f(ptx);
		if (!f.existsAsFile()) continue;

		if (f.getFileName() == String(name))
		{
			LOG(DBUG) << "Found " << f.getFileName();
			ptxStr = f.loadFileAsString();
			break;
		}
	}

	if (ptxStr == String::empty)
		throw std::runtime_error("Could not load ptx file: " + name);

	return ptxStr.toStdString();
}

void WhittedEngine::createGeomety()
{
	//
	// Build Custom Primitives
	//

	// Load AABB into device memory
	OptixAabb   aabb[OBJ_COUNT];
	CUdeviceptr d_aabb;

	sphere_bound(
		g_sphere.center, g_sphere.radius,
		reinterpret_cast<float*>(&aabb[0]));
	sphere_bound(
		g_sphere_shell.center, g_sphere_shell.radius2,
		reinterpret_cast<float*>(&aabb[1]));
	parallelogram_bound(
		g_floor.v1, g_floor.v2, g_floor.anchor,
		reinterpret_cast<float*>(&aabb[2]));

	CUDA_CHECK(cudaMalloc(reinterpret_cast<void**>(&d_aabb
		), OBJ_COUNT * sizeof(OptixAabb)));
	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(d_aabb),
		&aabb,
		OBJ_COUNT * sizeof(OptixAabb),
		cudaMemcpyHostToDevice
	));

	// Setup AABB build input
	uint32_t aabb_input_flags[] = {
		/* flags for metal sphere */
		OPTIX_GEOMETRY_FLAG_NONE,
		/* flag for glass sphere */
		OPTIX_GEOMETRY_FLAG_REQUIRE_SINGLE_ANYHIT_CALL,
		/* flag for floor */
		OPTIX_GEOMETRY_FLAG_NONE,
	};
	/* TODO: This API cannot control flags for different ray type */

	const uint32_t sbt_index[] = { 0, 1, 2 };
	CUdeviceptr    d_sbt_index;

	CUDA_CHECK(cudaMalloc(reinterpret_cast<void**>(&d_sbt_index), sizeof(sbt_index)));
	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(d_sbt_index),
		sbt_index,
		sizeof(sbt_index),
		cudaMemcpyHostToDevice));

	OptixBuildInput aabb_input = {};
	aabb_input.type = OPTIX_BUILD_INPUT_TYPE_CUSTOM_PRIMITIVES;
	aabb_input.aabbArray.aabbBuffers = &d_aabb;
	aabb_input.aabbArray.flags = aabb_input_flags;
	aabb_input.aabbArray.numSbtRecords = OBJ_COUNT;
	aabb_input.aabbArray.numPrimitives = OBJ_COUNT;
	aabb_input.aabbArray.sbtIndexOffsetBuffer = d_sbt_index;
	aabb_input.aabbArray.sbtIndexOffsetSizeInBytes = sizeof(uint32_t);
	aabb_input.aabbArray.primitiveIndexOffset = 0;


	OptixAccelBuildOptions accel_options = {
		OPTIX_BUILD_FLAG_ALLOW_COMPACTION,  // buildFlags
		OPTIX_BUILD_OPERATION_BUILD         // operation
	};


	buildGas(
		accel_options,
		aabb_input,
		state.gas_handle,
		state.d_gas_output_buffer);

	CUDA_CHECK(cudaFree((void*)d_aabb));
}

void WhittedEngine::createPipeline()
{
	std::vector<OptixProgramGroup> program_groups;

	state.pipeline_compile_options = {
		false,                                                  // usesMotionBlur
		OPTIX_TRAVERSABLE_GRAPH_FLAG_ALLOW_SINGLE_GAS,          // traversableGraphFlags
		5,    /* RadiancePRD uses 5 payloads */                 // numPayloadValues
		5,    /* Parallelogram intersection uses 5 attrs */     // numAttributeValues
		OPTIX_EXCEPTION_FLAG_NONE,                              // exceptionFlags
		"params"                                                // pipelineLaunchParamsVariableName
	};

	// Prepare program groups
	createModules();
	createCameraProgram( program_groups);
	createGlassSphereProgram( program_groups);
	createMetalSphereProgram(program_groups);
	createFloorProgram(program_groups);
	createMissProgram(program_groups);

	 // Link program groups to pipeline
    OptixPipelineLinkOptions pipeline_link_options = {
        max_trace,                          // maxTraceDepth
        OPTIX_COMPILE_DEBUG_LEVEL_FULL,     // debugLevel
        false                               // overrideUsesMotionBlur
    };
   
    OPTIX_CHECK_LOG( optixPipelineCreate(
        state.context,
        &state.pipeline_compile_options,
        &pipeline_link_options,
        program_groups.data(),
        static_cast<unsigned int>( program_groups.size() ),
        log,
        &sizeof_log,
        &state.pipeline ) );
}

void WhittedEngine::createSBT()
{
	// Raygen program record
	{
		CUdeviceptr d_raygen_record;
		size_t sizeof_raygen_record = sizeof(RayGenRecord);
		CUDA_CHECK(cudaMalloc(
			reinterpret_cast<void**>(&d_raygen_record),
			sizeof_raygen_record));

		state.sbt.raygenRecord = d_raygen_record;
	}

	// Miss program record
	{
		CUdeviceptr d_miss_record;
		size_t sizeof_miss_record = sizeof(MissRecord);
		CUDA_CHECK(cudaMalloc(
			reinterpret_cast<void**>(&d_miss_record),
			sizeof_miss_record * RAY_TYPE_COUNT));

		MissRecord ms_sbt[RAY_TYPE_COUNT];
		optixSbtRecordPackHeader(state.radiance_miss_prog_group, &ms_sbt[0]);
		optixSbtRecordPackHeader(state.occlusion_miss_prog_group, &ms_sbt[1]);
		ms_sbt[1].data = ms_sbt[0].data = { 0.34f, 0.55f, 0.85f };

		CUDA_CHECK(cudaMemcpy(
			reinterpret_cast<void*>(d_miss_record),
			ms_sbt,
			sizeof_miss_record * RAY_TYPE_COUNT,
			cudaMemcpyHostToDevice
		));

		state.sbt.missRecordBase = d_miss_record;
		state.sbt.missRecordCount = RAY_TYPE_COUNT;
		state.sbt.missRecordStrideInBytes = static_cast<uint32_t>(sizeof_miss_record);
	}

	// Hitgroup program record
	{
		const size_t count_records = RAY_TYPE_COUNT * OBJ_COUNT;
		HitGroupRecord hitgroup_records[count_records];

		// Note: Fill SBT record array the same order like AS is built.
		int sbt_idx = 0;

		// Metal Sphere
		OPTIX_CHECK(optixSbtRecordPackHeader(
			state.radiance_metal_sphere_prog_group,
			&hitgroup_records[sbt_idx]));
		hitgroup_records[sbt_idx].data.geometry.sphere = g_sphere;
		hitgroup_records[sbt_idx].data.shading.metal = {
			{ 0.2f, 0.5f, 0.5f },   // Ka
			{ 0.2f, 0.7f, 0.8f },   // Kd
			{ 0.9f, 0.9f, 0.9f },   // Ks
			{ 0.5f, 0.5f, 0.5f },   // Kr
			64,                     // phong_exp
		};
		sbt_idx++;

		OPTIX_CHECK(optixSbtRecordPackHeader(
			state.occlusion_metal_sphere_prog_group,
			&hitgroup_records[sbt_idx]));
		hitgroup_records[sbt_idx].data.geometry.sphere = g_sphere;
		sbt_idx++;

		// Glass Sphere
		OPTIX_CHECK(optixSbtRecordPackHeader(
			state.radiance_glass_sphere_prog_group,
			&hitgroup_records[sbt_idx]));
		hitgroup_records[sbt_idx].data.geometry.sphere_shell = g_sphere_shell;
		hitgroup_records[sbt_idx].data.shading.glass = {
			1e-2f,                                  // importance_cutoff
			{ 0.034f, 0.055f, 0.085f },             // cutoff_color
			3.0f,                                   // fresnel_exponent
			0.1f,                                   // fresnel_minimum
			1.0f,                                   // fresnel_maximum
			1.4f,                                   // refraction_index
			{ 1.0f, 1.0f, 1.0f },                   // refraction_color
			{ 1.0f, 1.0f, 1.0f },                   // reflection_color
			{ logf(.83f), logf(.83f), logf(.83f) }, // extinction_constant
			{ 0.6f, 0.6f, 0.6f },                   // shadow_attenuation
			10,                                     // refraction_maxdepth
			5                                       // reflection_maxdepth
		};
		sbt_idx++;

		OPTIX_CHECK(optixSbtRecordPackHeader(
			state.occlusion_glass_sphere_prog_group,
			&hitgroup_records[sbt_idx]));
		hitgroup_records[sbt_idx].data.geometry.sphere_shell = g_sphere_shell;
		hitgroup_records[sbt_idx].data.shading.glass.shadow_attenuation = { 0.6f, 0.6f, 0.6f };
		sbt_idx++;

		// Floor
		OPTIX_CHECK(optixSbtRecordPackHeader(
			state.radiance_floor_prog_group,
			&hitgroup_records[sbt_idx]));
		hitgroup_records[sbt_idx].data.geometry.parallelogram = g_floor;
		hitgroup_records[sbt_idx].data.shading.checker = {
			{ 0.8f, 0.3f, 0.15f },      // Kd1
			{ 0.9f, 0.85f, 0.05f },     // Kd2
			{ 0.8f, 0.3f, 0.15f },      // Ka1
			{ 0.9f, 0.85f, 0.05f },     // Ka2
			{ 0.0f, 0.0f, 0.0f },       // Ks1
			{ 0.0f, 0.0f, 0.0f },       // Ks2
			{ 0.0f, 0.0f, 0.0f },       // Kr1
			{ 0.0f, 0.0f, 0.0f },       // Kr2
			0.0f,                       // phong_exp1
			0.0f,                       // phong_exp2
			{ 32.0f, 16.0f }            // inv_checker_size
		};
		sbt_idx++;

		OPTIX_CHECK(optixSbtRecordPackHeader(
			state.occlusion_floor_prog_group,
			&hitgroup_records[sbt_idx]));
		hitgroup_records[sbt_idx].data.geometry.parallelogram = g_floor;

		CUdeviceptr d_hitgroup_records;
		size_t      sizeof_hitgroup_record = sizeof(HitGroupRecord);
		CUDA_CHECK(cudaMalloc(
			reinterpret_cast<void**>(&d_hitgroup_records),
			sizeof_hitgroup_record * count_records
		));

		CUDA_CHECK(cudaMemcpy(
			reinterpret_cast<void*>(d_hitgroup_records),
			hitgroup_records,
			sizeof_hitgroup_record * count_records,
			cudaMemcpyHostToDevice
		));

		state.sbt.hitgroupRecordBase = d_hitgroup_records;
		state.sbt.hitgroupRecordCount = count_records;
		state.sbt.hitgroupRecordStrideInBytes = static_cast<uint32_t>(sizeof_hitgroup_record);
	}
}

void WhittedEngine::initLaunchParams()
{
	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&state.params.accum_buffer),
		state.params.width * state.params.height * sizeof(float4)
	));
	state.params.frame_buffer = nullptr; // Will be set when output buffer is mapped

	state.params.subframe_index = 0u;

	state.params.light = g_light;
	state.params.ambient_light_color = make_float3(0.4f, 0.4f, 0.4f);
	state.params.max_depth = max_trace;
	state.params.scene_epsilon = 1.e-4f;

	CUDA_CHECK(cudaStreamCreate(&state.stream));
	CUDA_CHECK(cudaMalloc(reinterpret_cast<void**>(&state.d_params), sizeof(WhittedParams)));

	state.params.handle = state.gas_handle;
}

void WhittedEngine::updateBackgroundColor()
{
	Vector4f bg = properties.renderProps->getVal<Vector4f>(RenderKey::BackgroundColor);
	if (lastBackGround.isApprox(bg))
	{
		return;
	}
	else
	{
		lastBackGround = bg;
		restartAccum = true;

	}
	MissRecord ms_sbt;

	optixSbtRecordPackHeader(state.radiance_miss_prog_group, &ms_sbt);
	ms_sbt.data.bg_color.x = bg.x();
	ms_sbt.data.bg_color.y = bg.y();
	ms_sbt.data.bg_color.z = bg.z();

	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(state.sbt.missRecordBase),
		&ms_sbt,
		sizeof(MissRecord),
		cudaMemcpyHostToDevice
	));
}

void WhittedEngine::createModules()
{
	OptixModuleCompileOptions module_compile_options = {
	   100,                                    // maxRegisterCount
	   OPTIX_COMPILE_OPTIMIZATION_DEFAULT,     // optLevel
	   OPTIX_COMPILE_DEBUG_LEVEL_LINEINFO      // debugLevel
	};
	
	{
		const std::string ptx = getPtxString( "geometry.ptx");
		OPTIX_CHECK_LOG(optixModuleCreateFromPTX(
			state.context,
			&module_compile_options,
			&state.pipeline_compile_options,
			ptx.c_str(),
			ptx.size(),
			log,
			&sizeof_log,
			&state.geometry_module));
	}

	{
		const std::string ptx = getPtxString("camera.ptx");
		OPTIX_CHECK_LOG(optixModuleCreateFromPTX(
			state.context,
			&module_compile_options,
			&state.pipeline_compile_options,
			ptx.c_str(),
			ptx.size(),
			log,
			&sizeof_log,
			&state.camera_module));
	}

	{
		const std::string ptx = getPtxString("shading.ptx");
		OPTIX_CHECK_LOG(optixModuleCreateFromPTX(
			state.context,
			&module_compile_options,
			&state.pipeline_compile_options,
			ptx.c_str(),
			ptx.size(),
			log,
			&sizeof_log,
			&state.shading_module));
	}
}

void WhittedEngine::createCameraProgram( std::vector<OptixProgramGroup>& program_groups)
{
	OptixProgramGroup           cam_prog_group;
	OptixProgramGroupOptions    cam_prog_group_options = {};
	OptixProgramGroupDesc       cam_prog_group_desc = {};
	cam_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_RAYGEN;
	cam_prog_group_desc.raygen.module = state.camera_module;
	cam_prog_group_desc.raygen.entryFunctionName = "__raygen__pinhole_camera";

	OPTIX_CHECK_LOG(optixProgramGroupCreate(
		state.context,
		&cam_prog_group_desc,
		1,
		&cam_prog_group_options,
		log,
		&sizeof_log,
		&cam_prog_group));

	program_groups.push_back(cam_prog_group);
	state.raygen_prog_group = cam_prog_group;
}

void WhittedEngine::createGlassSphereProgram( std::vector<OptixProgramGroup>& program_groups)
{
	OptixProgramGroup           radiance_sphere_prog_group;
	OptixProgramGroupOptions    radiance_sphere_prog_group_options = {};
	OptixProgramGroupDesc       radiance_sphere_prog_group_desc = {};
	radiance_sphere_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP;
	radiance_sphere_prog_group_desc.hitgroup.moduleIS = state.geometry_module;
	radiance_sphere_prog_group_desc.hitgroup.entryFunctionNameIS = "__intersection__sphere_shell";
	radiance_sphere_prog_group_desc.hitgroup.moduleCH = state.shading_module;
	radiance_sphere_prog_group_desc.hitgroup.entryFunctionNameCH = "__closesthit__glass_radiance";
	radiance_sphere_prog_group_desc.hitgroup.moduleAH = nullptr;
	radiance_sphere_prog_group_desc.hitgroup.entryFunctionNameAH = nullptr;

	OPTIX_CHECK_LOG(optixProgramGroupCreate(
		state.context,
		&radiance_sphere_prog_group_desc,
		1,
		&radiance_sphere_prog_group_options,
		log,
		&sizeof_log,
		&radiance_sphere_prog_group));

	program_groups.push_back(radiance_sphere_prog_group);
	state.radiance_glass_sphere_prog_group = radiance_sphere_prog_group;

	OptixProgramGroup           occlusion_sphere_prog_group;
	OptixProgramGroupOptions    occlusion_sphere_prog_group_options = {};
	OptixProgramGroupDesc       occlusion_sphere_prog_group_desc = {};
	occlusion_sphere_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP;
	occlusion_sphere_prog_group_desc.hitgroup.moduleIS = state.geometry_module;
	occlusion_sphere_prog_group_desc.hitgroup.entryFunctionNameIS = "__intersection__sphere_shell";
	occlusion_sphere_prog_group_desc.hitgroup.moduleCH = nullptr;
	occlusion_sphere_prog_group_desc.hitgroup.entryFunctionNameCH = nullptr;
	occlusion_sphere_prog_group_desc.hitgroup.moduleAH = state.shading_module;
	occlusion_sphere_prog_group_desc.hitgroup.entryFunctionNameAH = "__anyhit__glass_occlusion";

	OPTIX_CHECK_LOG(optixProgramGroupCreate(
		state.context,
		&occlusion_sphere_prog_group_desc,
		1,
		&occlusion_sphere_prog_group_options,
		log,
		&sizeof_log,
		&occlusion_sphere_prog_group));

	program_groups.push_back(occlusion_sphere_prog_group);
	state.occlusion_glass_sphere_prog_group = occlusion_sphere_prog_group;
}

void WhittedEngine::createMetalSphereProgram( std::vector<OptixProgramGroup>& program_groups)
{
	OptixProgramGroup           radiance_sphere_prog_group;
	OptixProgramGroupOptions    radiance_sphere_prog_group_options = {};
	OptixProgramGroupDesc       radiance_sphere_prog_group_desc = {};
	radiance_sphere_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP,
		radiance_sphere_prog_group_desc.hitgroup.moduleIS = state.geometry_module;
	radiance_sphere_prog_group_desc.hitgroup.entryFunctionNameIS = "__intersection__sphere";
	radiance_sphere_prog_group_desc.hitgroup.moduleCH = state.shading_module;
	radiance_sphere_prog_group_desc.hitgroup.entryFunctionNameCH = "__closesthit__metal_radiance";
	radiance_sphere_prog_group_desc.hitgroup.moduleAH = nullptr;
	radiance_sphere_prog_group_desc.hitgroup.entryFunctionNameAH = nullptr;

	OPTIX_CHECK_LOG(optixProgramGroupCreate(
		state.context,
		&radiance_sphere_prog_group_desc,
		1,
		&radiance_sphere_prog_group_options,
		log,
		&sizeof_log,
		&radiance_sphere_prog_group));

	program_groups.push_back(radiance_sphere_prog_group);
	state.radiance_metal_sphere_prog_group = radiance_sphere_prog_group;

	OptixProgramGroup           occlusion_sphere_prog_group;
	OptixProgramGroupOptions    occlusion_sphere_prog_group_options = {};
	OptixProgramGroupDesc       occlusion_sphere_prog_group_desc = {};
	occlusion_sphere_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP,
		occlusion_sphere_prog_group_desc.hitgroup.moduleIS = state.geometry_module;
	occlusion_sphere_prog_group_desc.hitgroup.entryFunctionNameIS = "__intersection__sphere";
	occlusion_sphere_prog_group_desc.hitgroup.moduleCH = nullptr;
	occlusion_sphere_prog_group_desc.hitgroup.entryFunctionNameCH = nullptr;
	occlusion_sphere_prog_group_desc.hitgroup.moduleAH = state.shading_module;
	occlusion_sphere_prog_group_desc.hitgroup.entryFunctionNameAH = "__anyhit__full_occlusion";

	OPTIX_CHECK_LOG(optixProgramGroupCreate(
		state.context,
		&occlusion_sphere_prog_group_desc,
		1,
		&occlusion_sphere_prog_group_options,
		log,
		&sizeof_log,
		&occlusion_sphere_prog_group));

	program_groups.push_back(occlusion_sphere_prog_group);
	state.occlusion_metal_sphere_prog_group = occlusion_sphere_prog_group;
}

void WhittedEngine::createFloorProgram( std::vector<OptixProgramGroup>& program_groups)
{
	OptixProgramGroup           radiance_floor_prog_group;
	OptixProgramGroupOptions    radiance_floor_prog_group_options = {};
	OptixProgramGroupDesc       radiance_floor_prog_group_desc = {};
	radiance_floor_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP;
	radiance_floor_prog_group_desc.hitgroup.moduleIS = state.geometry_module;
	radiance_floor_prog_group_desc.hitgroup.entryFunctionNameIS = "__intersection__parallelogram";
	radiance_floor_prog_group_desc.hitgroup.moduleCH = state.shading_module;
	radiance_floor_prog_group_desc.hitgroup.entryFunctionNameCH = "__closesthit__checker_radiance";
	radiance_floor_prog_group_desc.hitgroup.moduleAH = nullptr;
	radiance_floor_prog_group_desc.hitgroup.entryFunctionNameAH = nullptr;

	OPTIX_CHECK_LOG(optixProgramGroupCreate(
		state.context,
		&radiance_floor_prog_group_desc,
		1,
		&radiance_floor_prog_group_options,
		log,
		&sizeof_log,
		&radiance_floor_prog_group));

	program_groups.push_back(radiance_floor_prog_group);
	state.radiance_floor_prog_group = radiance_floor_prog_group;

	OptixProgramGroup           occlusion_floor_prog_group;
	OptixProgramGroupOptions    occlusion_floor_prog_group_options = {};
	OptixProgramGroupDesc       occlusion_floor_prog_group_desc = {};
	occlusion_floor_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP;
	occlusion_floor_prog_group_desc.hitgroup.moduleIS = state.geometry_module;
	occlusion_floor_prog_group_desc.hitgroup.entryFunctionNameIS = "__intersection__parallelogram";
	occlusion_floor_prog_group_desc.hitgroup.moduleCH = nullptr;
	occlusion_floor_prog_group_desc.hitgroup.entryFunctionNameCH = nullptr;
	occlusion_floor_prog_group_desc.hitgroup.moduleAH = state.shading_module;
	occlusion_floor_prog_group_desc.hitgroup.entryFunctionNameAH = "__anyhit__full_occlusion";

	OPTIX_CHECK_LOG(optixProgramGroupCreate(
		state.context,
		&occlusion_floor_prog_group_desc,
		1,
		&occlusion_floor_prog_group_options,
		log,
		&sizeof_log,
		&occlusion_floor_prog_group));

	program_groups.push_back(occlusion_floor_prog_group);
	state.occlusion_floor_prog_group = occlusion_floor_prog_group;
}

void WhittedEngine::createMissProgram( std::vector<OptixProgramGroup>& program_groups)
{
	OptixProgramGroupOptions    miss_prog_group_options = {};
	OptixProgramGroupDesc       miss_prog_group_desc = {};
	miss_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_MISS;
	miss_prog_group_desc.miss.module = state.shading_module;
	miss_prog_group_desc.miss.entryFunctionName = "__miss__constant_bg";

	OPTIX_CHECK_LOG(optixProgramGroupCreate(
		state.context,
		&miss_prog_group_desc,
		1,
		&miss_prog_group_options,
		log,
		&sizeof_log,
		&state.radiance_miss_prog_group));

	miss_prog_group_desc.miss = {
		nullptr,    // module
		nullptr     // entryFunctionName
	};
	OPTIX_CHECK_LOG(optixProgramGroupCreate(
		state.context,
		&miss_prog_group_desc,
		1,
		&miss_prog_group_options,
		log,
		&sizeof_log,
		&state.occlusion_miss_prog_group));
}

void WhittedEngine::sphere_bound(float3 center, float radius, float result[6])
{
	OptixAabb* aabb = reinterpret_cast<OptixAabb*>(result);

	float3 m_min = center - radius;
	float3 m_max = center + radius;

	*aabb = {
		m_min.x, m_min.y, m_min.z,
		m_max.x, m_max.y, m_max.z
	};
}

void WhittedEngine::parallelogram_bound(float3 v1, float3 v2, float3 anchor, float result[6])
{
	// v1 and v2 are scaled by 1./length^2.  Rescale back to normal for the bounds computation.
	const float3 tv1 = v1 / dot(v1, v1);
	const float3 tv2 = v2 / dot(v2, v2);
	const float3 p00 = anchor;
	const float3 p01 = anchor + tv1;
	const float3 p10 = anchor + tv2;
	const float3 p11 = anchor + tv1 + tv2;

	OptixAabb* aabb = reinterpret_cast<OptixAabb*>(result);

	float3 m_min = fminf(fminf(p00, p01), fminf(p10, p11));
	float3 m_max = fmaxf(fmaxf(p00, p01), fmaxf(p10, p11));
	*aabb = {
		m_min.x, m_min.y, m_min.z,
		m_max.x, m_max.y, m_max.z
	};
}

void WhittedEngine::buildGas(const OptixAccelBuildOptions& accel_options, const OptixBuildInput& build_input, OptixTraversableHandle& gas_handle, CUdeviceptr& d_gas_output_buffer)
{
	OptixAccelBufferSizes gas_buffer_sizes;
	CUdeviceptr d_temp_buffer_gas;

	OPTIX_CHECK(optixAccelComputeMemoryUsage(
		state.context,
		&accel_options,
		&build_input,
		1,
		&gas_buffer_sizes));

	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&d_temp_buffer_gas),
		gas_buffer_sizes.tempSizeInBytes));

	// non-compacted output and size of compacted GAS
	CUdeviceptr d_buffer_temp_output_gas_and_compacted_size;
	size_t compactedSizeOffset = roundUp<size_t>(gas_buffer_sizes.outputSizeInBytes, 8ull);
	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&d_buffer_temp_output_gas_and_compacted_size),
		compactedSizeOffset + 8
	));

	OptixAccelEmitDesc emitProperty = {};
	emitProperty.type = OPTIX_PROPERTY_TYPE_COMPACTED_SIZE;
	emitProperty.result = (CUdeviceptr)((char*)d_buffer_temp_output_gas_and_compacted_size + compactedSizeOffset);

	OPTIX_CHECK(optixAccelBuild(
		state.context,
		0,
		&accel_options,
		&build_input,
		1,
		d_temp_buffer_gas,
		gas_buffer_sizes.tempSizeInBytes,
		d_buffer_temp_output_gas_and_compacted_size,
		gas_buffer_sizes.outputSizeInBytes,
		&gas_handle,
		&emitProperty,
		1));

	CUDA_CHECK(cudaFree((void*)d_temp_buffer_gas));

	size_t compacted_gas_size;
	CUDA_CHECK(cudaMemcpy(&compacted_gas_size, (void*)emitProperty.result, sizeof(size_t), cudaMemcpyDeviceToHost));

	if (compacted_gas_size < gas_buffer_sizes.outputSizeInBytes)
	{
		CUDA_CHECK(cudaMalloc(reinterpret_cast<void**>(&d_gas_output_buffer), compacted_gas_size));

		// use handle as input and output
		OPTIX_CHECK(optixAccelCompact(state.context, 0, gas_handle, d_gas_output_buffer, compacted_gas_size, &gas_handle));

		CUDA_CHECK(cudaFree((void*)d_buffer_temp_output_gas_and_compacted_size));
	}
	else
	{
		d_gas_output_buffer = d_buffer_temp_output_gas_and_compacted_size;
	}
}

void WhittedEngine::handleCameraUpdate( CameraHandle& camera)
{
	if (!restartAccum)
		return;

	restartAccum = false;

	// recalc the view matrix
	camera->getViewMatrix();

	const Vector3f& eye = camera->getEyePoint();
	const Vector3f& forward = camera->getFoward();
	const Vector3f& right = camera->getRight();
	const Vector3f& up = camera->getUp();

	float ulen, vlen, wlen;
	wlen = forward.norm();
	vlen = wlen * tanf(0.5f * camera->getFOV() * M_PIf / 180.0f);
	ulen = vlen * camera->getAspect();;

	float3 camRight, camUp, camForward, camEye;
	camUp = make_float3(up.x(), up.y(), up.z());
	camUp *= vlen;

	camRight = make_float3(right.x(), right.y(), right.z());
	camRight *= ulen;

	camForward = make_float3(forward.x(), forward.y(), forward.z());
	camEye = make_float3(eye.x(), eye.y(), eye.z());

	CameraData camData;
	camData.eye = camEye;
	camData.U = camRight;
	camData.V = camUp;
	camData.W = camForward;
	
	syncCameraDataToSbt(camData);
}

void WhittedEngine::syncCameraDataToSbt(const CameraData& camData)
{
	RayGenRecord rg_sbt;

	optixSbtRecordPackHeader(state.raygen_prog_group, &rg_sbt);
	rg_sbt.data = camData;

	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(state.sbt.raygenRecord),
		&rg_sbt,
		sizeof(RayGenRecord),
		cudaMemcpyHostToDevice
	));
}

void WhittedEngine::launchSubframe(CameraHandle& camera)
{
	// Launch
	uchar4* result_buffer_data = output_buffer.map();
	state.params.frame_buffer = result_buffer_data;
	CUDA_CHECK(cudaMemcpyAsync(reinterpret_cast<void*>(state.d_params),
		&state.params,
		sizeof(WhittedParams),
		cudaMemcpyHostToDevice,
		state.stream
	));

	OPTIX_CHECK(optixLaunch(
		state.pipeline,
		state.stream,
		reinterpret_cast<CUdeviceptr>(state.d_params),
		sizeof(WhittedParams),
		&state.sbt,
		state.params.width,  // launch width
		state.params.height, // launch height
		1                    // launch depth
	));
	output_buffer.unmap();
	CUDA_SYNC_CHECK();

	sabi::PixelBuffer& buffer = camera->getPixelBuffer();
	std::memcpy(buffer.uint8Pixels.data(), output_buffer.getHostPointer(), buffer.byteCountUint8());

	++state.params.subframe_index;
}

void WhittedEngine::updateState(CameraHandle& camera)
{
	// Update params on device
	if (restartAccum || resize_dirty)
		state.params.subframe_index = 0;

	handleCameraUpdate(camera);
	handleResize(state.params);
}

void WhittedEngine::handleResize(WhittedParams& params)
{
	if (!resize_dirty)
		return;
	resize_dirty = false;

	output_buffer.resize(params.width, params.height);

	// Realloc accumulation buffer
	CUDA_CHECK(cudaFree(reinterpret_cast<void*>(params.accum_buffer)));
	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&params.accum_buffer),
		params.width * params.height * sizeof(float4)
	));
}
