// This header file was auto-generated by ClassMate++
// Created: 18 Aug 2019 6:10:35 am
// Copyright (c) 2019, HurleyWorks

#pragma once

#include <sabi_core/sabi_core.h>
#include <concurrent.hpp>

using handleType = std::unique_ptr<uint8_t[], void(*)(void*)>;

using sabi::PixelBuffer;
using sabi::PrimitiveType;
using sabi::RenderableDesc;
using sabi::MeshOptions;
using sabi::MeshBuffersHandle;
using sabi::LoadStrategyHandle;
using sabi::RenderableNode;
using sabi::RenderableData;
using Eigen::Vector2f;
using sabi::ActiveLoader;
using sabi::LoadMeshCallback;

class Model : public CsSignal::SlotBase, public CsSignal::SignalBase
{
	//https://www.bogotobogo.com/DesignPatterns/mvc_model_view_controller_pattern.php
	// Manages the app data and state
	// Not concerned with UI or presentation
	// Often persists somewhere
	// Same model should be reusable, unchanged in different interfaces

public:
	using ErrorQueue = std::queue<ErrMsg>;
	using MeshQueue = moodycamel::ConcurrentQueue<MeshBuffersHandle>;

	SIGNAL_1(void emitRenderable(RenderableNode& node))
	SIGNAL_2(emitRenderable, node)

 public:
	Model (const PropertyService& properties);
	~Model ();

	ErrMsg getNextErrorMessage()
	{
		if (!errorQueue.empty())
		{
			ErrMsg error = errorQueue.front();
			errorQueue.pop();
			return error;
		}
		return ErrMsg();
	}

	MeshBuffersHandle getNextLoadedMeshBuffer()
	{
		MeshBuffersHandle mesh;
		bool found = meshQueue.try_dequeue(mesh);

		return found ? mesh : nullptr;
	}

	void addPrimitive(PrimitiveType type, MeshOptions options = MeshOptions());
	void createGroundPlane(const Vector2f& size);
	void onMeshLoad(MeshBuffersHandle m);
	void addMesh(MeshBuffersHandle mesh,
				const std::string& name,
				BodyID clientID,
				const Pose& pose,
				const Scale& scale,
				const RenderableDesc& desc,
				MeshOptions options);

	void loadImage(const std::string& path, PixelBuffer & buffer);
	void onDrop(const std::vector<std::string>& fileList);

	void createNewRenderable(const RenderableData& d);
	void createNewInstance(const RenderableData& d);

	void addNode(RenderableNode& node);
	void removeNode(RenderableNode& node);
	void removeNode(ItemID itemID);

	void clearScene();
	
 private:
	PropertyService properties;
	LoadMeshCallback loadMeshCallback = nullptr;
	RenderableNode world = nullptr;
	LoadStrategyHandle loadStrategy = nullptr;
	ErrorQueue errorQueue;
	MeshQueue meshQueue;
	concurrent<ActiveLoader> activeLoader;

}; // end class Model
