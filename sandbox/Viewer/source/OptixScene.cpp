
// This source file was auto-generated by ClassMate++
// Created: 18 Aug 2019 4:00:14 pm
// Copyright (c) 2019, HurleyWorks

#include "OptixScene.h"
#include "Renderer.h"
#include "WhittedContext.h"

using Eigen::Vector4f;
using Eigen::Vector3f;

// ctor
OptixScene::OptixScene (const PropertyService& properties)
	: OptixEngine(properties)
{	

}

// dtor
OptixScene::~OptixScene ()
{	

}

void OptixScene::init(CameraHandle& camera)
{
	renderer = Renderer::create(camera->getScreenWidth(), camera->getScreenHeight());
	createProgramDatabase();
	rebuildSceneAccel();
}

void OptixScene::addPipeline(PipelineType type, const json& groups, OptixConfig& config)
{
	PipelineHandle pipeHandle = createPipeline(groups, config);
	if (!pipeHandle)
		throw std::runtime_error("Pipeline creation failed");

	pipelineDB.insert(std::make_pair(PipelineType(type).ToString(), pipeHandle));

	// create a render context for each pipeline
	switch (type)
	{
		case PipelineType::Whitted:
		{
			OptixRenderContextHandle whittedContext = WhittedContext::create();

			whittedContext->setConfig(config);
			whittedContext->setPipeline(pipeHandle);
			whittedContext->setSceneAccel(getIAS());
			whittedContext->setDimensions(renderer->getDimensions());

			whittedContext->initializeLaunchParams();

			whittedContext->createRaygenRecord(getPtr());
			whittedContext->createMissRecord(getPtr());
			whittedContext->createEmptyHitGroupRecord(getPtr());

			// add it to the render queue
			renderer->addRenderContext(whittedContext);
		}
		break;

		default:
			break;
	}
}

void OptixScene::addRenderable(RenderableNode& node)
{
	if (!node) return;

	ScopedStopWatch sw(_FN_);

	try
	{
		OptixMeshHandle mesh = OptixMesh::create(node);
		mesh->init(context);
		meshes.push_back(mesh);

		// rebuild the hitgroup section of the SBT
		for (auto & context : renderer->getRenderQueue())
		{
			context->rebuildHitgroupSBT(meshes);
		}

		// rebuild the top level IAS
		rebuildSceneAccel();
	
		// must restart render
		setRenderRestart(true);
	}
	catch (const std::runtime_error& e)
	{
		ok = false;
		LOG(CRITICAL) << e.what();
	}
	catch (const std::bad_alloc& e)
	{
		ok = false;
		LOG(CRITICAL) << e.what();
	}
	catch (...)
	{
		ok = false;
		LOG(CRITICAL) << "Caught unknow exception";
	}
}

void OptixScene::clearScene()
{
	meshes.clear();
	for (auto& context : renderer->getRenderQueue())
	{
		context->rebuildHitgroupSBT(meshes);
		context->createEmptyHitGroupRecord(getPtr());
	}

	rebuildSceneAccel();
	setRenderRestart(true);
}


void OptixScene::onInput(const InputEvent& input)
{
	this->input = input;

}

