
// This source file was auto-generated by ClassMate++
// Created: 18 Aug 2019 4:00:14 pm
// Copyright (c) 2019, HurleyWorks

#include "OptixScene.h"
#include "Renderer.h"
#include "WhittedContext.h"

using Eigen::Vector4f;
using Eigen::Vector3f;

// ctor
OptixScene::OptixScene (const PropertyService& properties)
	: OptixEngine(properties)
{	

}

// dtor
OptixScene::~OptixScene ()
{	
	try
	{
		if (deviceIASoutputBuffer)
			CUDA_CHECK(cudaFree(reinterpret_cast<void*>(deviceIASoutputBuffer)));
	}
	catch (const std::runtime_error& e)
	{
		LOG(CRITICAL) << e.what();
	}
	catch (...)
	{
		LOG(CRITICAL) << "Caught unknow exception";
	}
}

void OptixScene::init(CameraHandle& camera)
{
	renderer = Renderer::create(camera->getScreenWidth(), camera->getScreenHeight());
	createProgramDatabase();
	rebuildSceneAccel();
}

void OptixScene::addPipeline(PipelineType type, const json& groups, OptixConfig& config)
{
	PipelineHandle pipeHandle = createPipeline(groups, config);
	if (!pipeHandle)
		throw std::runtime_error("Pipeline creation failed");

	pipelineDB.insert(std::make_pair(PipelineType(type).ToString(), pipeHandle));

	// create a render context for each pipeline
	switch (type)
	{
		case PipelineType::Whitted:
		{
			OptixRenderContextHandle whittedContext = WhittedContext::create();

			whittedContext->setConfig(config);
			whittedContext->setPipeline(pipeHandle);
			whittedContext->setSceneAccel(getIAS());
			whittedContext->setDimensions(renderer->getDimensions());

			whittedContext->initializeLaunchParams();

			whittedContext->createRaygenRecord(getPtr());
			whittedContext->createMissRecord(getPtr());
			whittedContext->createEmptyHitGroupRecord(getPtr());

			// add it to the render queue
			renderer->addRenderContext(whittedContext);
		}
		break;

		default:
			break;
	}
}

void OptixScene::addRenderable(RenderableNode& node)
{
	if (!node) return;

	ScopedStopWatch sw(_FN_);

	try
	{
		OptixMeshHandle mesh = OptixMesh::create(node);
		mesh->init(context);
		meshes.push_back(mesh);

		// rebuild the hitgroup section of the SBT
		for (auto & context : renderer->getRenderQueue())
		{
			context->rebuildHitgroupSBT(meshes);
		}

		// rebuild the top level IAS
		rebuildSceneAccel();
	
		// must restart render
		setRenderRestart(true);
	}
	catch (const std::runtime_error& e)
	{
		ok = false;
		LOG(CRITICAL) << e.what();
	}
	catch (const std::bad_alloc& e)
	{
		ok = false;
		LOG(CRITICAL) << e.what();
	}
	catch (...)
	{
		ok = false;
		LOG(CRITICAL) << "Caught unknow exception";
	}
}

void OptixScene::clearScene()
{
	meshes.clear();
	for (auto& context : renderer->getRenderQueue())
	{
		context->rebuildHitgroupSBT(meshes);
		context->createEmptyHitGroupRecord(getPtr());
	}

	rebuildSceneAccel();
	setRenderRestart(true);
}

void OptixScene::rebuildSceneAccel()
{
	const size_t instanceCount = meshes.size();

	// out with the old buffer
	if(deviceIASoutputBuffer)
		CUDA_CHECK(cudaFree(reinterpret_cast<void*>(deviceIASoutputBuffer)));

	std::vector<OptixInstance> optixInstances(instanceCount);

	unsigned int sbtOffset = 0; 
	for (size_t i = 0; i < meshes.size(); ++i)
	{
		auto& mesh = meshes[i];
		auto& optixInstance = optixInstances[i];
		memset(&optixInstance, 0, sizeof(OptixInstance));

		optixInstance.flags = OPTIX_INSTANCE_FLAG_NONE;
		optixInstance.instanceId = static_cast<unsigned int>(i);
		optixInstance.sbtOffset = sbtOffset;
		optixInstance.visibilityMask = 1;
		optixInstance.traversableHandle = mesh->getGAS();
		memcpy(optixInstance.transform, mesh->getWorldTransform().data(), sizeof(float) * 12);

		sbtOffset += 1* PICK_RAY_TYPE_COUNT;
	}

	const size_t instancesSizeInBytes = sizeof(OptixInstance) * instanceCount;
	CUdeviceptr  deviceInstances;
	CUDA_CHECK(cudaMalloc(reinterpret_cast<void**>(&deviceInstances), instancesSizeInBytes));
	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(deviceInstances),
		optixInstances.data(),
		instancesSizeInBytes,
		cudaMemcpyHostToDevice
	));

	OptixAccelBuildOptions accelOptions = {};
	accelOptions.buildFlags = OPTIX_BUILD_FLAG_NONE;
	accelOptions.operation = OPTIX_BUILD_OPERATION_BUILD;

	OptixBuildInput instanceInput = {};
	instanceInput.type = OPTIX_BUILD_INPUT_TYPE_INSTANCES;
	instanceInput.instanceArray.instances = deviceInstances;
	instanceInput.instanceArray.numInstances = static_cast<unsigned int>(instanceCount);

	OptixAccelBufferSizes IASbufferSizes;
	OPTIX_CHECK(optixAccelComputeMemoryUsage(
		context->get(),
		&accelOptions,
		&instanceInput,
		1, // num build inputs
		&IASbufferSizes
	));

	CUdeviceptr deviceTempBuffer;
	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&deviceTempBuffer),
		IASbufferSizes.tempSizeInBytes
	));
	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&deviceIASoutputBuffer),
		IASbufferSizes.outputSizeInBytes
	));

	OPTIX_CHECK(optixAccelBuild(
		context->get(),
		nullptr,                  // CUDA stream
		&accelOptions,
		&instanceInput,
		1,                  // num build inputs
		deviceTempBuffer,
		IASbufferSizes.tempSizeInBytes,
		deviceIASoutputBuffer,
		IASbufferSizes.outputSizeInBytes,
		&sceneAccel,
		nullptr,            // emitted property list
		0                   // num emitted properties
	));

	CUDA_CHECK(cudaFree(reinterpret_cast<void*>(deviceTempBuffer)));
	CUDA_CHECK(cudaFree(reinterpret_cast<void*>(deviceInstances)));
}




