// This source file was auto-generated by ClassMate++
// Created: 28 Sep 2019 6:48:49 pm
// Copyright (c) 2019, HurleyWorks

#include "WhittedContext.h"

using sabi::PixelBuffer;
using Eigen::Vector4f;
using Eigen::Vector3f;

void WhittedContext::createRaygenRecord(const OptixEngineRef& engine)
{
	ProgramGroupHandle raygen = nullptr;

	auto it = config.programs.find(raygenName);
	if (it != config.programs.end())
		raygen = it->second;

	if (!raygen)
		throw std::runtime_error("No pick raygen program found!");

	CUdeviceptr  d_raygenRecord;

	CUDA_CHECK(cudaMalloc(reinterpret_cast<void**>(&d_raygenRecord), raygenRecordSize));


	OPTIX_CHECK(optixSbtRecordPackHeader(raygen->get(), &raygenRecord));
	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(d_raygenRecord),
		&raygenRecord,
		raygenRecordSize,
		cudaMemcpyHostToDevice
	));

	sbt.raygenRecord = d_raygenRecord;
}

void WhittedContext::createMissRecord(const OptixEngineRef& engine)
{
	ProgramGroupHandle miss = nullptr;
	auto it = config.programs.find(radianceMissName);
	if (it != config.programs.end())
		miss = it->second;

	if (!miss)
		throw std::runtime_error("No pick miss program found!");

	CUdeviceptr d_missRecord;

	CUDA_CHECK(cudaMalloc(reinterpret_cast<void**>(&d_missRecord), missRecordSize));

	// get the miss color from the user
	Vector4f bg = engine->props().renderProps->getVal<Vector4f>(RenderKey::BackgroundColor);
	missRecord.data.r = bg.x();
	missRecord.data.b = bg.y();
	missRecord.data.g = bg.z();

	OPTIX_CHECK(optixSbtRecordPackHeader(miss->get(), &missRecord));
	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(d_missRecord),
		&missRecord,
		missRecordSize,
		cudaMemcpyHostToDevice
	));

	sbt.missRecordBase = d_missRecord;
	sbt.missRecordStrideInBytes = missRecordSize;
	sbt.missRecordCount = WhitedRayType::WHITTED_RAY_TYPE_COUNT;
}

void WhittedContext::createEmptyHitGroupRecord(const OptixEngineRef& engine)
{
	hitProg = nullptr;

	auto it = config.programs.find(radianceHitName);
	if (it != config.programs.end())
		hitProg = it->second;

	if (!hitProg)
		throw std::runtime_error("No pick hit program found!");

	HitGroupRecord rec = {};
	memset(&rec, 0, hitgroup_record_size);
	OPTIX_CHECK(optixSbtRecordPackHeader(hitProg->get(), &rec));
	hitgroup_records.push_back(rec);

	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&sbt.hitgroupRecordBase),
		hitgroup_record_size * hitgroup_records.size()
	));
	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(sbt.hitgroupRecordBase),
		hitgroup_records.data(),
		hitgroup_record_size * hitgroup_records.size(),
		cudaMemcpyHostToDevice
	));

	sbt.hitgroupRecordStrideInBytes = static_cast<unsigned int>(hitgroup_record_size);
	sbt.hitgroupRecordCount = static_cast<unsigned int>(hitgroup_records.size());
}

void WhittedContext::rebuildHitgroupSBT(const SceneMeshes& meshes)
{
	ProgramGroupHandle radianceHit = nullptr;
	auto it = config.programs.find(radianceHitName);
	if (it != config.programs.end())
		radianceHit = it->second;

	if (!radianceHit)
		throw std::runtime_error("No radiance hit program found!");

	ProgramGroupHandle occulsionHit = nullptr;
	auto itr = config.programs.find(occlusionHitName);
	if (itr != config.programs.end())
		occulsionHit = itr->second;

	if (!occulsionHit)
		throw std::runtime_error("No occulsion hit program found!");

	// delete the old hitgroup records
	CUDA_CHECK(cudaFree(reinterpret_cast<void*>(sbt.hitgroupRecordBase)));
	sbt.hitgroupRecordBase = 0;
	sbt.hitgroupRecordCount = 0;
	sbt.hitgroupRecordStrideInBytes = 0;
	hitgroup_records.clear(); // d'uh forgetting to do this was the cause of much crashing

	for (auto mesh : meshes)
	{
		HitGroupRecord rec = {};

		OPTIX_CHECK(optixSbtRecordPackHeader(radianceHit->get(), &rec));

		rec.data.geometry_data.type = OptixGeometryData::TRIANGLE_MESH;
		rec.data.geometry_data.triangle_mesh.positions = mesh->positions;
		rec.data.geometry_data.triangle_mesh.normals = mesh->normals;
		rec.data.geometry_data.triangle_mesh.texcoords = mesh->texcoords;
		rec.data.geometry_data.triangle_mesh.indices = mesh->indices;

		// use default material 
		rec.data.material_data.pbr = OptixMaterialData::Pbr();

		hitgroup_records.push_back(rec);

		OPTIX_CHECK(optixSbtRecordPackHeader(occulsionHit->get(), &rec));
		hitgroup_records.push_back(rec);
	}

	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&sbt.hitgroupRecordBase),
		hitgroup_record_size * hitgroup_records.size()
	));
	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(sbt.hitgroupRecordBase),
		hitgroup_records.data(),
		hitgroup_record_size * hitgroup_records.size(),
		cudaMemcpyHostToDevice
	));

	sbt.hitgroupRecordStrideInBytes = static_cast<unsigned int>(hitgroup_record_size);
	sbt.hitgroupRecordCount = static_cast<unsigned int>(hitgroup_records.size());
}

void WhittedContext::launch(OptixEngineRef& engine)
{
	whittedParams.frame_buffer = renderBuffer.map();
	whittedParams.sceneAccel = engine->getIAS();
	whittedParams.gamma = engine->props().renderProps->getVal<float>(RenderKey::Gamma);

	// if the scene has changed we need 
	// to resart the accumulator by setting
	// the params.subframe_index  to 0
	if (engine->restartRender())
	{
		whittedParams.subframe_index = 0;
		engine->setRenderRestart(false);
	}
	else
	{
		whittedParams.subframe_index++;
	}

	uploadLaunchParameters(whittedParams);

	OptixRenderContext::launch(engine);
}

void WhittedContext::updateCamera(CameraHandle& camera)
{
	if (!camera->isDirty()) return;
	
	// recalc the view matrix
	camera->getViewMatrix();
	
	const Vector3f& eye = camera->getEyePoint();
	const Vector3f& forward = camera->getFoward();
	const Vector3f& right = camera->getRight();
	const Vector3f& up = camera->getUp();

	float ulen, vlen, wlen;
	wlen = forward.norm();
	vlen = wlen * tanf(0.5f * camera->getFOV() * M_PIf / 180.0f);
	ulen = vlen * camera->getAspect();;

	float3 camRight, camUp, camForward, camEye;
	camUp = make_float3(up.x(), up.y(), up.z());
	camUp *= vlen;

	camRight = make_float3(right.x(), right.y(), right.z());
	camRight *= ulen;

	camForward = make_float3(forward.x(), forward.y(), forward.z());
	camEye = make_float3(eye.x(), eye.y(), eye.z());

	raygenRecord.data.cam_eye = camEye;
	raygenRecord.data.camera_u = camRight;
	raygenRecord.data.camera_v = camUp;
	raygenRecord.data.camera_w = camForward;

	// sync to device
	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(sbt.raygenRecord),
		&raygenRecord,
		sizeof(RaygenRecord),
		cudaMemcpyHostToDevice
	)); 
}

void WhittedContext::initializeLaunchParams()
{
	renderBuffer.init(CUDAOutputBufferType::ZERO_COPY, size.x(), size.y());

	// create the accumulation buffer
	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&whittedParams.accum_buffer),
		size.x() * size.y() * sizeof(float4)
	));

	whittedParams.frame_buffer = nullptr; // Will be set when output buffer is mapped

	whittedParams.subframe_index = 0u;

	const float loffset = 5.0f; //  scene.aabb().maxExtent();

	/// TODO: add light support to sutil::Scene
	std::vector<OptixLight::Point> lights(2);
	lights[0].color = { 1.0f, 1.0f, 0.8f };
	lights[0].intensity = 5.0f;
	lights[0].position = make_float3(loffset);
	lights[0].falloff = OptixLight::Falloff::QUADRATIC;
	lights[1].color = { 0.8f, 0.8f, 1.0f };
	lights[1].intensity = 2.0f;
	lights[1].position = make_float3(-loffset, 0.5f * loffset, -0.5f * loffset);
	lights[1].falloff = OptixLight::Falloff::QUADRATIC;

	whittedParams.lights.count = static_cast<uint32_t>(lights.size());
	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&whittedParams.lights.data),
		lights.size() * sizeof(OptixLight::Point)
	));

	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(whittedParams.lights.data),
		lights.data(),
		lights.size() * sizeof(OptixLight::Point),
		cudaMemcpyHostToDevice
	));

	whittedParams.sceneAccel = 0;
	whittedParams.gamma = DEFAULT_RENDER_GAMMA;

	deviceParams.alloc(sizeof(whittedParams));
	uploadLaunchParameters(whittedParams);
}

void WhittedContext::preLaunch(CameraHandle& camera, OptixEngineRef& engine)
{
	// sync background color from user
	Vector4f bg = engine->props().renderProps->getVal<Vector4f>(RenderKey::BackgroundColor);

	missRecord.data.r = bg.x();
	missRecord.data.g = bg.y();
	missRecord.data.b = bg.z();

	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(sbt.missRecordBase),
		&missRecord,
		sizeof(MissRecord),
		cudaMemcpyHostToDevice
	));
}

void WhittedContext::postLaunch(CameraHandle& camera, OptixEngineRef& engine)
{
	renderBuffer.unmap();

	// acquire the Optix render 
	PixelBuffer& pixels = camera->getPixelBuffer();
	std::memcpy(pixels.uint8Pixels.data(), renderBuffer.getHostPointer(), pixels.byteCountUint8());
}

