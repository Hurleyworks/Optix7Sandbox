// This source file was auto-generated by ClassMate++
// Created: 18 Aug 2019 6:10:35 am
// Copyright (c) 2019, HurleyWorks

#include <stb_image.h>
#include "jahley/window/platform/opengl/NanoguiLayer.h"
#include "jahley/window/platform/opengl/OpenglTexture.h"
#include <sabi_core/sabi_core.h>

#include "View.h"

using namespace nanogui;
using juce::String;
using std::cout;
using std::endl;

// ctor
View::View (const PropertyService& properties, const std::string& resourceFolder)
	: properties(properties),
	  resourceFolder(resourceFolder)
{	
}

// dtor
View::~View ()
{	
}

void View::create(NanoguiLayer* const gui)
{
	// this is mostly the Nanogui example_1 code

	this->gui = gui;

	auto ctx = gui->nvgContext();

	Window* window = new Window(gui, "Button demo");
	window->setPosition(Vector2i(15, 15));
	window->setLayout(new GroupLayout());

	/* No need to store a pointer, the data structure will be automatically
	   freed when the parent window is deleted */
	new Label(window, "Push buttons", "sans-bold");

	Button* b = new Button(window, "Plain button");
	b->setCallback([] { cout << "pushed!" << endl; });
	b->setTooltip("short tooltip");

	/* Alternative construction notation using variadic template */
	b = window->add<Button>("Styled", ENTYPO_ICON_ROCKET);
	b->setBackgroundColor(Color(0, 0, 255, 25));
	b->setCallback([] { cout << "pushed!" << endl; });
	b->setTooltip("This button has a fairly long tooltip. It is so long, in "
		"fact, that the shown text will span several lines.");

	new Label(window, "Toggle buttons", "sans-bold");
	b = new Button(window, "Toggle me");
	b->setFlags(Button::ToggleButton);
	b->setChangeCallback([](bool state) { cout << "Toggle button state: " << state << endl; });

	new Label(window, "Radio buttons", "sans-bold");
	b = new Button(window, "Radio button 1");
	b->setFlags(Button::RadioButton);
	b = new Button(window, "Radio button 2");
	b->setFlags(Button::RadioButton);

	new Label(window, "A tool palette", "sans-bold");
	Widget* tools = new Widget(window);
	tools->setLayout(new BoxLayout(Orientation::Horizontal,
		Alignment::Middle, 0, 6));

	b = new ToolButton(tools, ENTYPO_ICON_CLOUD);
	b = new ToolButton(tools, ENTYPO_ICON_CONTROLLER_FAST_FORWARD);
	b = new ToolButton(tools, ENTYPO_ICON_COMPASS);
	b = new ToolButton(tools, ENTYPO_ICON_INSTALL);

	new Label(window, "Popup buttons", "sans-bold");
	PopupButton* popupBtn = new PopupButton(window, "Popup", ENTYPO_ICON_EXPORT);
	Popup* popup = popupBtn->popup();
	popup->setLayout(new GroupLayout());
	new Label(popup, "Arbitrary widgets can be placed here");
	new CheckBox(popup, "A check box");
	// popup right
	popupBtn = new PopupButton(popup, "Recursive popup", ENTYPO_ICON_FLASH);
	Popup* popupRight = popupBtn->popup();
	popupRight->setLayout(new GroupLayout());
	new CheckBox(popupRight, "Another check box");
	// popup left
	popupBtn = new PopupButton(popup, "Recursive popup", ENTYPO_ICON_FLASH);
	popupBtn->setSide(Popup::Side::Left);
	Popup* popupLeft = popupBtn->popup();
	popupLeft->setLayout(new GroupLayout());
	new CheckBox(popupLeft, "Another check box");

	window = new Window(gui, "Basic widgets");
	window->setPosition(Vector2i(200, 15));
	window->setLayout(new GroupLayout());

	new Label(window, "Message dialog", "sans-bold");
	tools = new Widget(window);
	tools->setLayout(new BoxLayout(Orientation::Horizontal,
		Alignment::Middle, 0, 6));
	b = new Button(tools, "Info");
	b->setCallback([=] {
		auto dlg = new MessageDialog(gui, MessageDialog::Type::Information, "Title", "This is an information message");
		dlg->setCallback([](int result) { cout << "Dialog result: " << result << endl; });
		});
	b = new Button(tools, "Warn");
	b->setCallback([=] {
		auto dlg = new MessageDialog(gui, MessageDialog::Type::Warning, "Title", "This is a warning message");
		dlg->setCallback([](int result) { cout << "Dialog result: " << result << endl; });
		});
	b = new Button(tools, "Ask");
	b->setCallback([=] {
		auto dlg = new MessageDialog(gui, MessageDialog::Type::Warning, "Title", "This is a question message", "Yes", "No", true);
		dlg->setCallback([](int result) { cout << "Dialog result: " << result << endl; });
		});

	std::vector<std::pair<int, std::string>> icons = loadImageDirectory(ctx, resourceFolder + "/icons");
	std::string resourcesFolderPath = resourceFolder + "/icons/";

	new Label(window, "Image panel & scroll panel", "sans-bold");
	PopupButton* imagePanelBtn = new PopupButton(window, "Image Panel");
	imagePanelBtn->setIcon(ENTYPO_ICON_FOLDER);
	popup = imagePanelBtn->popup();
	VScrollPanel* vscroll = new VScrollPanel(popup);
	ImagePanel* imgPanel = new ImagePanel(vscroll);
	imgPanel->setImages(icons);
	popup->setFixedSize(Vector2i(245, 150));

	auto imageWindow = new Window(gui, "Selected image");
	imageWindow->setPosition(Vector2i(710, 15));
	imageWindow->setLayout(new GroupLayout());

	// Load all of the images by creating a GLTexture object and saving the pixel data.
	for (auto& icon : icons) 
	{
		LOG(DBUG) << icon.second;
		GLTexture texture(icon.second);
		auto data = texture.load(icon.second + ".png");
		mImagesData.emplace_back(std::move(texture), std::move(data));
	}

	// Set the first texture
	auto imageView = new ImageView(imageWindow, mImagesData[0].first.texture());
	mCurrentImage = 0;
	// Change the active textures.
	imgPanel->setCallback([this, imageView](int i) {
		imageView->bindImage(mImagesData[i].first.texture());
		mCurrentImage = i;
		cout << "Selected item " << i << '\n';
		});

	imageView->setGridThreshold(20);
	imageView->setPixelInfoThreshold(20);
	imageView->setPixelInfoCallback(
		[this, imageView](const Vector2i& index) -> std::pair<std::string, Color> {
			auto& imageData = mImagesData[mCurrentImage].second;
			auto& textureSize = imageView->imageSize();
			std::string stringData;
			uint16_t channelSum = 0;
			for (int i = 0; i != 4; ++i) {
				auto& channelData = imageData[4 * index.y() * textureSize.x() + 4 * index.x() + i];
				channelSum += channelData;
				stringData += (std::to_string(static_cast<int>(channelData)) + "\n");
			}
			float intensity = static_cast<float>(255 - (channelSum / 4)) / 255.0f;
			float colorScale = intensity > 0.5f ? (intensity + 1) / 2 : intensity / 2;
			Color textColor = Color(colorScale, 1.0f);
			return { stringData, textColor };
		});

	new Label(window, "File dialog", "sans-bold");
	tools = new Widget(window);
	tools->setLayout(new BoxLayout(Orientation::Horizontal,
		Alignment::Middle, 0, 6));
	b = new Button(tools, "Open");
	b->setCallback([&] {
		cout << "File dialog result: " << file_dialog(
			{ {"png", "Portable Network Graphics"}, {"txt", "Text file"} }, false) << endl;
		});
	b = new Button(tools, "Save");
	b->setCallback([&] {
		cout << "File dialog result: " << file_dialog(
			{ {"png", "Portable Network Graphics"}, {"txt", "Text file"} }, true) << endl;
		});

	new Label(window, "Combo box", "sans-bold");
	new ComboBox(window, { "Combo box item 1", "Combo box item 2", "Combo box item 3" });
	new Label(window, "Check box", "sans-bold");
	CheckBox* cb = new CheckBox(window, "Flag 1",
		[](bool state) { cout << "Check box 1 state: " << state << endl; }
	);
	cb->setChecked(true);
	cb = new CheckBox(window, "Flag 2",
		[](bool state) { cout << "Check box 2 state: " << state << endl; }
	);
	new Label(window, "Progress bar", "sans-bold");
	mProgress = new ProgressBar(window);

	new Label(window, "Slider and text box", "sans-bold");

	Widget* panel = new Widget(window);
	panel->setLayout(new BoxLayout(Orientation::Horizontal,
		Alignment::Middle, 0, 20));

	Slider* slider = new Slider(panel);
	slider->setValue(0.5f);
	slider->setFixedWidth(80);

	TextBox* textBox = new TextBox(panel);
	textBox->setFixedSize(Vector2i(60, 25));
	textBox->setValue("50");
	textBox->setUnits("%");
	slider->setCallback([textBox](float value) {
		textBox->setValue(std::to_string((int)(value * 100)));
		});
	slider->setFinalCallback([&](float value) {
		cout << "Final slider value: " << (int)(value * 100) << endl;
		});
	textBox->setFixedSize(Vector2i(60, 25));
	textBox->setFontSize(20);
	textBox->setAlignment(TextBox::Alignment::Right);

	window = new Window(gui, "Misc. widgets");
	window->setPosition(Vector2i(425, 15));
	window->setLayout(new GroupLayout());

	tabWidget = window->add<TabWidget>();

	Widget* layer = tabWidget->createTab("Color Wheel");
	layer->setLayout(new GroupLayout());

	// Use overloaded variadic add to fill the tab widget with Different tabs.
	layer->add<Label>("Color wheel widget", "sans-bold");
	layer->add<ColorWheel>();

	layer = tabWidget->createTab("Function Graph");
	layer->setLayout(new GroupLayout());

	layer->add<Label>("Function graph widget", "sans-bold");

	Graph* graph = layer->add<Graph>("Some Function");

	graph->setHeader("E = 2.35e-3");
	graph->setFooter("Iteration 89");
	VectorXf& func = graph->values();
	func.resize(100);
	for (int i = 0; i < 100; ++i)
		func[i] = 0.5f * (0.5f * std::sin(i / 10.f) +
			0.5f * std::cos(i / 23.f) + 1);

	// Dummy tab used to represent the last tab button.
	tabWidget->createTab("+");

	// A simple counter.
	
	tabWidget->setCallback([=](int index) mutable {
		if (index == (tabWidget->tabCount() - 1)) {
			// When the "+" tab has been clicked, simply add a new tab.
			std::string tabName = "Dynamic " + std::to_string(counter);
			Widget* layerDyn = tabWidget->createTab(index, tabName);
			layerDyn->setLayout(new GroupLayout());
			layerDyn->add<Label>("Function graph widget", "sans-bold");
			Graph* graphDyn = layerDyn->add<Graph>("Dynamic function");

			graphDyn->setHeader("E = 2.35e-3");
			graphDyn->setFooter("Iteration " + std::to_string(index * counter));
			VectorXf& funcDyn = graphDyn->values();
			funcDyn.resize(100);
			for (int i = 0; i < 100; ++i)
				funcDyn[i] = 0.5f *
				std::abs((0.5f * std::sin(i / 10.f + counter) +
					0.5f * std::cos(i / 23.f + 1 + counter)));
			++counter;
			// We must invoke perform layout from the screen instance to keep everything in order.
			// This is essential when creating tabs dynamically.
			gui->performLayout();
			// Ensure that the newly added header is visible on screen
			tabWidget->ensureTabVisible(index);

		}
		});
	tabWidget->setActiveTab(0);

	// A button to go back to the first tab and scroll the window.
	panel = window->add<Widget>();
	panel->add<Label>("Jump to tab: ");
	panel->setLayout(new BoxLayout(Orientation::Horizontal,
		Alignment::Middle, 0, 6));

	auto ib = panel->add<IntBox<int>>();
	ib->setEditable(true);

	b = panel->add<Button>("", ENTYPO_ICON_FORWARD);
	b->setFixedSize(Vector2i(22, 22));
	ib->setFixedHeight(22);
	b->setCallback([&, ib] {
		int value = ib->value();
		if (value >= 0 && value < tabWidget->tabCount()) {
			tabWidget->setActiveTab(value);
			tabWidget->ensureTabVisible(value);
		}
		});

	window = new Window(gui, "Grid of small widgets");
	window->setPosition(Vector2i(425, 300));
	GridLayout* layout =
		new GridLayout(Orientation::Horizontal, 2,
			Alignment::Middle, 15, 5);
	layout->setColAlignment(
		{ Alignment::Maximum, Alignment::Fill });
	layout->setSpacing(0, 10);
	window->setLayout(layout);

	/* FP widget */ {
		new Label(window, "Floating point :", "sans-bold");
		textBox = new TextBox(window);
		textBox->setEditable(true);
		textBox->setFixedSize(Vector2i(100, 20));
		textBox->setValue("50");
		textBox->setUnits("GiB");
		textBox->setDefaultValue("0.0");
		textBox->setFontSize(16);
		textBox->setFormat("[-]?[0-9]*\\.?[0-9]+");
	}

	/* Positive integer widget */ {
		new Label(window, "Positive integer :", "sans-bold");
		auto intBox = new IntBox<int>(window);
		intBox->setEditable(true);
		intBox->setFixedSize(Vector2i(100, 20));
		intBox->setValue(50);
		intBox->setUnits("Mhz");
		intBox->setDefaultValue("0");
		intBox->setFontSize(16);
		intBox->setFormat("[1-9][0-9]*");
		intBox->setSpinnable(true);
		intBox->setMinValue(1);
		intBox->setValueIncrement(2);
	}

	/* Checkbox widget */ {
		new Label(window, "Checkbox :", "sans-bold");

		cb = new CheckBox(window, "Check me");
		cb->setFontSize(16);
		cb->setChecked(true);
	}

	new Label(window, "Combo box :", "sans-bold");
	ComboBox* cobo =
		new ComboBox(window, { "Item 1", "Item 2", "Item 3" });
	cobo->setFontSize(16);
	cobo->setFixedSize(Vector2i(100, 20));

	new Label(window, "Color picker :", "sans-bold");
	auto cp = new ColorPicker(window, { 255, 120, 0, 255 });
	cp->setFixedSize({ 100, 20 });
	cp->setFinalCallback([](const Color& c) {
		std::cout << "ColorPicker Final Callback: ["
			<< c.r() << ", "
			<< c.g() << ", "
			<< c.b() << ", "
			<< c.w() << "]" << std::endl;
		});
	// setup a fast callback for the color picker widget on a new window
	// for demonstrative purposes
	window = new Window(gui, "Color Picker Fast Callback");
	layout =
		new GridLayout(Orientation::Horizontal, 2,
			Alignment::Middle, 15, 5);
	layout->setColAlignment(
		{ Alignment::Maximum, Alignment::Fill });
	layout->setSpacing(0, 10);
	window->setLayout(layout);
	window->setPosition(Vector2i(425, 500));
	new Label(window, "Combined: ");
	b = new Button(window, "ColorWheel", ENTYPO_ICON_500PX);
	new Label(window, "Red: ");
	auto redIntBox = new IntBox<int>(window);
	redIntBox->setEditable(false);
	new Label(window, "Green: ");
	auto greenIntBox = new IntBox<int>(window);
	greenIntBox->setEditable(false);
	new Label(window, "Blue: ");
	auto blueIntBox = new IntBox<int>(window);
	blueIntBox->setEditable(false);
	new Label(window, "Alpha: ");
	auto alphaIntBox = new IntBox<int>(window);
	cp->setCallback([b, redIntBox, blueIntBox, greenIntBox, alphaIntBox](const Color& c) {
		b->setBackgroundColor(c);
		b->setTextColor(c.contrastingColor());
		int red = (int)(c.r() * 255.0f);
		redIntBox->setValue(red);
		int green = (int)(c.g() * 255.0f);
		greenIntBox->setValue(green);
		int blue = (int)(c.b() * 255.0f);
		blueIntBox->setValue(blue);
		int alpha = (int)(c.w() * 255.0f);
		alphaIntBox->setValue(alpha);

		});

	gui->performLayout();
}

const StringArray View::getSceneInfo()
{
	StringArray message;

	uint64_t totalMeshes = properties.worldProps->getVal<uint64_t>(WorldKey::TotalMeshes);
	uint64_t totalInstances = properties.worldProps->getVal<uint64_t>(WorldKey::TotalInstances);
	uint64_t totalInstancedTriangles = properties.worldProps->getVal<uint64_t>(WorldKey::TotalInstancedTriangles);
	uint64_t totalTriangles = properties.worldProps->getVal<uint64_t>(WorldKey::TotalRealTriangles);

	message.add(String("Total meshes: ") + String(totalMeshes));
	message.add(String("Total instances: ") + String(totalInstances));
	message.add(String("Total mesh triangles: ") + String(totalTriangles));
	message.add(String("Total instanced triangles: ") + String(totalInstancedTriangles));

	return message;
}