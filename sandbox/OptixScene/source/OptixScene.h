// This header file was auto-generated by ClassMate++
// Created: 18 Aug 2019 4:00:14 pm
// Copyright (c) 2019, HurleyWorks

#pragma once

#include <optix7_core/optix7_core.h>
#include "EngineData.h"

using Eigen::Vector4f;
using Eigen::Matrix4f;
using Eigen::AlignedBox3f;

using SceneHandle = std::shared_ptr<class OptixScene>;

// the bulk of this code is from the Optix7 MeshViewer sample
class OptixScene //: public OptixEngine
{

public:
	struct MeshGroup
	{
		std::string                      name;
		Matrix4f                         transform;

		std::vector<GenericBufferView>    indices;
		std::vector<BufferView<float3> >  positions;
		std::vector<BufferView<float3> >  normals;
		std::vector<BufferView<float2> >  texcoords;

		std::vector<int32_t>              material_idx;

		OptixTraversableHandle            gas_handle = 0;
		CUdeviceptr                       d_gas_output = 0;

		AlignedBox3f                      object_aabb;
		AlignedBox3f                      world_aabb;
	};

 public:
	OptixScene (const PropertyService& properties);
	~OptixScene ();

	void init(CameraHandle& camera);// override;
	void render(CameraHandle& camera)// override
	{
		restartAccum = camera->isDirty();
		launchSubframe(camera);	
	}

	 void addCamera(const CameraHandle& camera) { m_cameras.push_back(camera); }
	 void addMesh(std::shared_ptr<MeshGroup> mesh) { m_meshes.push_back(mesh); }
	 void addMaterial(const MaterialData::Pbr& mtl) { m_materials.push_back(mtl); }
	 void addBuffer(const uint64_t buf_size, const void* data);
	 std::string getPtxString(const std::string& name);

	 CUdeviceptr                    getBuffer(int32_t buffer_index)const;
	

	 void                           finalize();
	 void                           cleanup();

	 CameraHandle                                  camera()const;
	 OptixPipeline                             pipeline()const { return m_pipeline; }
	 const OptixShaderBindingTable* sbt()const { return &m_sbt; }
	 OptixTraversableHandle                    traversableHandle() const { return m_ias_handle; }
	 AlignedBox3f                             aabb() const { return m_scene_aabb; }
	 OptixDeviceContext                        context() const { return m_context; }
	 const std::vector<MaterialData::Pbr>& materials() const { return m_materials; }
	 const std::vector<std::shared_ptr<MeshGroup>>& meshes() const { return m_meshes; }

	 void createContext();
	 void buildMeshAccels();
	 void buildInstanceAccel(int rayTypeCount = whitted::RAY_TYPE_COUNT);

 private:
	PropertyService properties;
	bool resize_dirty = false;
	bool restartAccum = true;
	Vector4f lastBackGround = Vector4f::Constant(0.0);

	whitted::LaunchParams* d_params = nullptr;
	whitted::LaunchParams   params = {};
	int32_t                 width = 768;
	int32_t                 height = 768;


	CUDAOutputBuffer<uchar4> output_buffer;

	void createPTXModule();
	void createProgramGroups();
	void createPipeline();
	void createSBT();
	void initLaunchParams(CameraHandle& camera);
	void launchSubframe(CameraHandle& camera);

	std::vector<CameraHandle>                  m_cameras;
	std::vector<std::shared_ptr<MeshGroup> >  m_meshes;
	std::vector<MaterialData::Pbr>       m_materials;
	std::vector<CUdeviceptr>             m_buffers;

	AlignedBox3f                        m_scene_aabb;

	OptixDeviceContext                   m_context = 0;
	OptixShaderBindingTable              m_sbt = {};
	OptixPipelineCompileOptions          m_pipeline_compile_options = {};
	OptixPipeline                        m_pipeline = 0;
	OptixModule                          m_ptx_module = 0;

	OptixProgramGroup                    m_raygen_prog_group = 0;
	OptixProgramGroup                    m_radiance_miss_group = 0;
	OptixProgramGroup                    m_occlusion_miss_group = 0;
	OptixProgramGroup                    m_radiance_hit_group = 0;
	OptixProgramGroup                    m_occlusion_hit_group = 0;
	OptixTraversableHandle               m_ias_handle = 0;
	CUdeviceptr                          m_d_ias_output_buffer = 0;

}; // end class OptixScene
