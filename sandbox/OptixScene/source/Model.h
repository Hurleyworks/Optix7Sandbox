// This header file was auto-generated by ClassMate++
// Created: 18 Aug 2019 6:10:35 am
// Copyright (c) 2019, HurleyWorks

#pragma once

#include <sabi_core/sabi_core.h>
#include "OptixScene.h"

using handleType = std::unique_ptr<uint8_t[], void(*)(void*)>;
using sabi::PrimitiveType;
using sabi::RenderableDesc;
using sabi::MeshOptions;
using sabi::MeshBuffersHandle;
using sabi::MeshBuffers;
using sabi::Surface;
using sabi::PixelBuffer;
using sabi::LoadStrategyHandle;
using sabi::RenderableNode;
using sabi::RenderableData;

class Model : public CsSignal::SlotBase
{
	//https://www.bogotobogo.com/DesignPatterns/mvc_model_view_controller_pattern.php
	// Manages the app data and state
	// Not concerned with UI or presentation
	// Often persists somewhere
	// Same model should be reusable, unchanged in different interfaces

public:
	using ErrorQueue = std::queue<ErrMsg>;

 public:
	Model (const PropertyService& properties);
	~Model ();

	SceneHandle createScene(CameraHandle & camera, const OptixConfig & config)
	{
		scene = std::make_shared<OptixScene>(properties, config);

		scene->init(camera);


		for (auto it : world->getChildren())
		{
			RenderableNode node = it.second;
			if (!node) continue;

			MeshBuffersHandle m = node->getMesh();

			MeshBuffers* meshBuf = m.get();
			MatrixXf V = *(MatrixXf*)(meshBuf);
			LOG(DBUG) << V.cols();

			size_t off = sizeof(Eigen::Vector3f) * 4;
			MatrixXf N = *(MatrixXf*)(meshBuf + off);
			LOG(DBUG) << N.cols();


			size_t vertices = m->pointCount();
			size_t triangles = m->triangleCount();
			size_t normals = vertices;

			const uint64_t buf_size = vertices * sizeof(float) * 3 + normals * sizeof(float) * 3 + triangles * sizeof(unsigned int) * 3;
			const uint64_t buf_size2 = sizeof(*m.get());
			scene->addBuffer(buf_size, m.get());

			auto mesh = std::make_shared<OptixScene::MeshGroup>();
			scene->addMesh(mesh);

			mesh->name = node->getName();
			mesh->transform = node->getSpaceTime().worldTransform.matrix();

			MatrixXu tris;
			m->getAllSurfaceIndices(tris);

			size_t byteOffset = 0;

			const CUdeviceptr buffer_base = scene->getBuffer(0);
			GenericBufferView buffer_view;
			buffer_view.data = buffer_base + byteOffset;
			buffer_view.byte_stride = static_cast<uint16_t>(sizeof(unsigned int) * 3);
			buffer_view.count = static_cast<uint32_t>(tris.cols()); 
			buffer_view.elmt_byte_size = static_cast<uint16_t>(sizeof(unsigned int));

			LOG(DBUG) << "byte stride: " << buffer_view.byte_stride;
			LOG(DBUG) << "count: " << buffer_view.count;
			LOG(DBUG) << "element size: " << buffer_view.elmt_byte_size;

			if (buffer_view.isValid())
			{
				mesh->indices.push_back(buffer_view);
			}
			else
			{
				LOG(CRITICAL) << "Could not create indices for " << node->getName();
			}
			
			byteOffset += buffer_view.byte_stride * buffer_view.count * buffer_view.elmt_byte_size;

			LOG(DBUG) << sizeof(*m.get());
			LOG(DBUG) << "BYTE OFFSET " << byteOffset;

			/*MeshBuffers* buf = m.get();

			for (int i = 0; i < 12; i++)
			{
				float* p = reinterpret_cast<float*>(buf + byteOffset + i * 3);
				LOG(DBUG) << *p;
			}*/
			
			

		}
		//scene->finalize();

		return scene;
	}

	void postError(ErrMsg err)
	{
		errorQueue.push(err);
	}

	ErrMsg getNextErrorMessage()
	{
		if (!errorQueue.empty())
		{
			ErrMsg error = errorQueue.front();
			errorQueue.pop();
			return error;
		}
		return ErrMsg();
	}

	void loadPrimitive(PrimitiveType type, MeshOptions options = MeshOptions());
	void createGroundPlane(const Eigen::Vector2f& size);

	void loadImage(const std::string& path, PixelBuffer & buffer);
	void onDrop(const std::vector<std::string>& fileList);

	void createNewRenderable(const RenderableData& d);
	void createNewInstance(const RenderableData& d);

	void addNode(RenderableNode& node);
	void removeNode(RenderableNode& node);
	void removeNode(ItemID itemID);

	void clearScene();
	
 private:
	SceneHandle scene = nullptr;
	PropertyService properties;
	RenderableNode world = nullptr;
	LoadStrategyHandle loadStrategy = nullptr;
	ErrorQueue errorQueue;

	void addMesh(MeshBuffersHandle mesh,
				 const std::string& name,
				 BodyID clientID,
				 const Pose& pose,
				 const Scale& scale,
				 const RenderableDesc& desc,
				 MeshOptions options);

	

}; // end class Model
