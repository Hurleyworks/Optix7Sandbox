
// This source file was auto-generated by ClassMate++
// Created: 18 Aug 2019 4:00:14 pm
// Copyright (c) 2019, HurleyWorks

#include "OptixScene.h"
#include "Renderer.h"
#include "DreamerContext.h"

using Eigen::Vector4f;
using Eigen::Vector3f;

// ctor
OptixScene::OptixScene (const PropertyService& properties)
	: OptixEngine(properties)
{	

}

// dtor
OptixScene::~OptixScene ()
{	
	meshHandler.reset(); // this frees the sbt.hitgroupRecordBase
	renderer->getRenderQueue().clear();
}

void OptixScene::init(CameraHandle& camera)
{
	renderer = Renderer::create(camera->getScreenWidth(), camera->getScreenHeight());
	createProgramDatabase();
	rebuildSceneAccel();
}


void OptixScene::addPipeline(PipelineType type, const json& groups, OptixConfig& config)
{
	PipelineHandle pipeHandle = createPipeline(groups, config);
	if (!pipeHandle)
		throw std::runtime_error("Pipeline creation failed");

	pipelineDB.insert(std::make_pair(PipelineType(type).ToString(), pipeHandle));

	// create a render context for each pipeline
	switch (type)
	{
		case PipelineType::Dreamer:
		{
			dreamerConfig = config;
			OptixRenderContextHandle dreamerContext = DreamerContext::create(type);

			dreamerContext->setConfig(config);
			dreamerContext->setPipeline(pipeHandle);
			dreamerContext->setSceneAccel(getIAS());
			dreamerContext->setDimensions(renderer->getDimensions());

			dreamerContext->initializeLaunchParams();

			dreamerContext->createRaygenRecord(getPtr());
			dreamerContext->createMissRecord(getPtr());
			dreamerContext->createEmptyHitGroupRecord(getPtr());

			// add it to the render queue
			renderer->addRenderContext(dreamerContext);
		}
		break;

		default:
			break;
	}
}

void OptixScene::addRenderable(RenderableNode& node, bool rebuildAccel)
{
	if (!node) return;

	OptixMeshHandle mesh = OptixMesh::create(node);
	mesh->init(context);
		
	for (auto & context : renderer->getRenderQueue())
	{
		if(context->getType() == PipelineType::Dreamer)
			meshHandler.addMesh(mesh, context->getSBT(), dreamerConfig.programs);
	}

	if(rebuildAccel)
		rebuildSceneAccel();
	
	// must restart render
	setRenderRestart(true);
	
}

void OptixScene::addRenderableList(const RenderableList&& nodes)
{
	{
		ScopedStopWatch sw(_FN_);
		for (auto node : nodes)
		{
			addRenderable(node, false);
		}
	}
	
	{
		ScopedStopWatch sw(_FN_);
		rebuildSceneAccel();
	}
	
}

void OptixScene::clearScene()
{
	rebuildSceneAccel();
	meshHandler.reset();
	for (auto& context : renderer->getRenderQueue())
	{
		context->rebuildHitgroupSBT(OptixEngine::getPtr());
		context->createEmptyHitGroupRecord(getPtr());
	}

	resetSceneAccell();
	
	setRenderRestart(true);
}

void OptixScene::applyMotion()
{
	MotionType motionType = properties.worldProps->getVal<MotionType>(WorldKey::MotionType);

	switch (motionType)
	{
		case MotionType::None:
			break;

		case MotionType::Reset:
			meshHandler.resetMotion();
			setRenderRestart(true);
			rebuildSceneAccel(true); // just update is needed

			// otherwise we'll never get any AA
			properties.worldProps->setValue(WorldKey::MotionType, MotionType(MotionType::None));
			break;

		case MotionType::RandomJitter:
		{
			for (auto mesh : meshHandler.getMeshes())
			{
				// don't move the ground plane
				if (mesh->getNode()->getSpaceTime().is2D()) continue;

				// slowly move up
				mesh->getNode()->getSpaceTime().worldTransform.translate(Vector3f(0.0f, 0.001f, 0.0f));

				// apply random rotation around Y axis
				float angle_in_radian = wabi::Math<float>::symetricRandom();
				angle_in_radian *= .25f;

				Quaternionf q;
				q = AngleAxisf(angle_in_radian, Vector3f::UnitY());
				mesh->getNode()->getSpaceTime().worldTransform.rotate(q);
			}

			// just update instead of the more expensive rebuild if no new mesh has been added
			bool justUpdate = meshHandler.getMeshes().size() && meshHandler.getMeshes().size() == lastMeshCount;
			rebuildSceneAccel(justUpdate);

			// must restart passes when there's motion
			setRenderRestart(true);
			break;
		}
	}

	// remember how many meshes there are
	lastMeshCount = meshHandler.getMeshes().size();
}





