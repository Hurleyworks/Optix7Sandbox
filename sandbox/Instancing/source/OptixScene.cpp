
// This source file was auto-generated by ClassMate++
// Created: 18 Aug 2019 4:00:14 pm
// Copyright (c) 2019, HurleyWorks

#include "OptixScene.h"
#include "Renderer.h"
#include "PickingContext.h"
#include "WhittedContext.h"

using Eigen::Vector4f;
using Eigen::Vector3f;

// ctor
OptixScene::OptixScene (const PropertyService& properties)
	: OptixEngine(properties)
{	

}

// dtor
OptixScene::~OptixScene ()
{	
	
}

void OptixScene::init(CameraHandle& camera)
{
	renderer = Renderer::create(camera->getScreenWidth(), camera->getScreenHeight());
	createProgramDatabase();
	rebuildSceneAccel();
}


void OptixScene::addPipeline(PipelineType type, const json& groups, OptixConfig& config)
{
	PipelineHandle pipeHandle = createPipeline(groups, config);
	if (!pipeHandle)
		throw std::runtime_error("Pipeline creation failed");

	pipelineDB.insert(std::make_pair(PipelineType(type).ToString(), pipeHandle));

	// create a render context for each pipeline
	switch (type)
	{
		case PipelineType::Picking:
		{
			OptixRenderContextHandle pickContext = PickingContext::create(type);

			pickContext->setConfig(config);
			pickContext->setPipeline(pipeHandle);
			pickContext->setSceneAccel(getIAS());
			pickContext->setDimensions(Vector3i(1, 1, 1));

			pickContext->initializeLaunchParams();

			pickContext->createRaygenRecord(getPtr());
			pickContext->createMissRecord(getPtr());
			pickContext->createEmptyHitGroupRecord(getPtr());

			// add it to the render queue
			renderer->addRenderContext(pickContext);
		}
		break;

		case PipelineType::Whitted:
		{
			whittedConfig = config;
			OptixRenderContextHandle whittedContext = WhittedContext::create(type);

			whittedContext->setConfig(config);
			whittedContext->setPipeline(pipeHandle);
			whittedContext->setSceneAccel(getIAS());
			whittedContext->setDimensions(renderer->getDimensions());

			whittedContext->initializeLaunchParams();

			whittedContext->createRaygenRecord(getPtr());
			whittedContext->createMissRecord(getPtr());
			whittedContext->createEmptyHitGroupRecord(getPtr());

			// add it to the render queue
			renderer->addRenderContext(whittedContext);
		}
		break;

		default:
			break;
	}
}

void OptixScene::addRenderable(RenderableNode& node)
{
	if (!node) return;

	ScopedStopWatch sw(_FN_);

	try
	{
		OptixMeshHandle mesh = OptixMesh::create(node);
		mesh->init(context);
		
		for (auto & context : renderer->getRenderQueue())
		{
			if(context->getType() == PipelineType::Whitted)
				meshHandler.addMesh(mesh, context->getSBT(), whittedConfig.programs);
			else
				context->rebuildHitgroupSBT(OptixEngine::getPtr());
		}

		rebuildSceneAccel();
	
		// must restart render
		setRenderRestart(true);
	}
	catch (const std::runtime_error& e)
	{
		LOG(CRITICAL) << e.what();
	}
	catch (const std::bad_alloc& e)
	{
		LOG(CRITICAL) << e.what();
	}
	catch (...)
	{
		LOG(CRITICAL) << "Caught unknow exception";
	}
}

void OptixScene::clearScene()
{
	meshHandler.reset();
	for (auto& context : renderer->getRenderQueue())
	{
		context->rebuildHitgroupSBT(OptixEngine::getPtr());
		context->createEmptyHitGroupRecord(getPtr());
	}

	rebuildSceneAccel();
	setRenderRestart(true);
}

void OptixScene::onInput(const InputEvent& input)
{
	this->input = input;

}




