// This source file was auto-generated by ClassMate++
// Created: 18 Aug 2019 6:10:35 am
// Copyright (c) 2019, HurleyWorks

#include "Model.h"
#include <stb_image.h>

using juce::File;
using juce::StringArray;
using juce::String;
using mace::FileServices;
using sabi::InputEvent;
using sabi::Surface;
using sabi::SpaceTime;
using sabi::MeshBuffers;
using sabi::NormalizedClump;
using sabi::MeshOps;
using Eigen::AlignedBox3f;


// ctor
Model::Model ()
{	
	loadStrategy = std::make_shared<NormalizedClump>();
}

// dtor
Model::~Model ()
{	
}

void Model::loadPrimitive(PrimitiveType type, MeshOptions options)
{
	MeshBuffersHandle mesh = sabi::MeshOps::createPrimitiveMesh(PrimitiveType(type));
	if (!mesh)
	{
		// FIXME get some error handling going 
		return;
	}

	// must compute the face count! // FIXME make this automatic so the user doesn't forget
	MatrixXu triangles;
	mesh->getAllSurfaceIndices(triangles);

	LOG(DBUG) << PrimitiveType(type).toString() << " has " << triangles.size() << " triangles and " << mesh->V.cols() << " vertices";

	AlignedBox3f modelBound;
	modelBound.min() = mesh->V.rowwise().minCoeff();
	modelBound.max() = mesh->V.rowwise().maxCoeff();
	float s = 1.0f;

	// this might change scale!
	if ((options & MeshOptions::NormalizeSize) == MeshOptions::NormalizeSize)
	{
		MeshOps::normalizeSize(mesh, modelBound, s);
	}

	if ((options & MeshOptions::CenterVertices) == MeshOptions::CenterVertices)
	{
		MeshOps::centerVertices(mesh, modelBound, s);
	}

	SpaceTime spacetime;
	spacetime.modelBound.min() = mesh->V.rowwise().minCoeff();
	spacetime.modelBound.max() = mesh->V.rowwise().maxCoeff();
	spacetime.worldTransform = Pose::Identity();
	spacetime.scale = Scale::Constant(1.0f);

	if ((options & MeshOptions::LoadStrategy) == MeshOptions::LoadStrategy)
	{
		loadStrategy->addNextItem(spacetime);
	}

	if ((options & MeshOptions::RestOnGround) == MeshOptions::RestOnGround)
	{
		spacetime.worldTransform.translation().y() = -spacetime.modelBound.min().y();
	}

	spacetime.startTransform = spacetime.worldTransform;

	spacetime.updateWorldBounds(true);

	spacetime.debug();
}

void Model::createGroundPlane(const Eigen::Vector2f& size)
{
	std::string name = "Default 2D ground plane";

	MatrixXu F; // faces
	MatrixXf V; // vertices
	MatrixXf N; // vertex normals

	V.resize(3, 4);
	V.col(0) = Eigen::Vector3f(-size.x(), 0.0f, size.y());
	V.col(1) = Eigen::Vector3f(size.x(), 0.0f, size.y());
	V.col(2) = Eigen::Vector3f(size.x(), 0.0f, -size.y());
	V.col(3) = Eigen::Vector3f(-size.x(), 0.0f, -size.y());

	F.resize(3, 2);
	F.col(0) = Vector3u(0, 1, 2);
	F.col(1) = Vector3u(2, 3, 0);

	N.resize(3, 4);
	N.col(0) = N.col(1) = N.col(2) = N.col(3) = Eigen::Vector3f::UnitY();

	SpaceTime spacetime;
	spacetime.modelBound.min() = V.rowwise().minCoeff();
	spacetime.modelBound.max() = V.rowwise().maxCoeff();
	spacetime.worldTransform = Pose::Identity();
	spacetime.startTransform = Pose::Identity();
	spacetime.scale = Scale::Constant(1.0f);
	spacetime.updateWorldBounds();

	MeshBuffersHandle m = std::make_shared<MeshBuffers>();
	m->V = V;
	m->N = N;

	Surface s;
	s.indices() = F;
	m->S.push_back(s);
}

void Model::loadImage(const std::string& path, PixelBuffer & buffer)
{
	int force_channels = 0;

	handleType pixels(stbi_load(path.c_str(), &buffer.spec.width, &buffer.spec.height, &buffer.spec.channels, force_channels), stbi_image_free);
	if (pixels)
	{
		int pixelCount = buffer.getPixelCount();
		int bytes = pixelCount * buffer.spec.channels * sizeof(uint8_t);

		buffer.uint8Pixels.resize(buffer.spec.channels, pixelCount);
		std::memcpy(buffer.uint8Pixels.data(), pixels.get(), bytes);
	}
}

void Model::onDrop(const std::vector<std::string>& fileList)
{
	for (auto p : fileList)
	{
		File f(p);
		if (f.isDirectory())
		{
			StringArray files;
			String wildCard("*.*");
			FileServices::getFiles(f.getFullPathName(), files, wildCard);

			for (auto path : files)
			{
				File f(path);
				std::string filename = f.getFullPathName().toStdString();
				LOG(DBUG) << filename;
			}
		}
		else if (f.existsAsFile())
		{
			std::string filename = f.getFullPathName().toStdString();
			LOG(DBUG) << filename;
		}
	}
}

void Model::addMesh(MeshBuffersHandle mesh, 
					const std::string& name,
					BodyID clientID, 
					const Pose& pose,
					const Scale& scale,
					const RenderableDesc& desc,
					MeshOptions options)
{



}

