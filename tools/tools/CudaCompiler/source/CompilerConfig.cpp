// This source file was auto-generated by ClassMate++
// Created: 29 Aug 2019 3:54:59 pm
// Copyright (c) 2019, HurleyWorks

#include "CompilerConfig.h"

using juce::File;
using juce::DynamicObject;
using juce::var;
using juce::JSON;
using juce::FileOutputStream;

const String CUDA_FOLDER = "cuda_input_folder";
const String PTX_FOLDER = "ptx_output_folder";
const String INCLUDE_FOLDER1 = "include_folder_1";
const String INCLUDE_FOLDER2 = "include_folder_2";
const String INCLUDE_FOLDER3 = "include_folder_3";
const String INCLUDE_FOLDER4 = "include_folder_4";

// ctor
CompilerConfig::CompilerConfig (const PropertyService& properties)
	: properties(properties)
{	
}

// dtor
CompilerConfig::~CompilerConfig ()
{	
	Result res = saveConfig();
	if (!res.wasOk())
	{
		LOG(CRITICAL) << res.getErrorMessage();
	}
}

void CompilerConfig::init()
{
	configFolder = String(properties.renderProps->getVal<std::string>(RenderKey::ResourceFolder));
	File f(configFolder);
	if (!f.exists())
	{
		throw std::runtime_error("No resource folder found at " + configFolder.toStdString());
	}
}

void CompilerConfig::loadConfig(const std::string& configName)
{
	File configFile(configName);
	if (!configFile.existsAsFile())
	{
		throw std::runtime_error("Config file not found: " + configName);
	}

	var v = JSON::parse(configFile);
	DynamicObject::Ptr data = v.getDynamicObject();
	if (!data)
		throw std::runtime_error("Compiler connfig file is empty!");

	if (data->hasProperty(CUDA_FOLDER))
	{
		cudaFolder = data->getProperty(CUDA_FOLDER);
		emitCudaFolder(cudaFolder.toStdString());
	}

	if (data->hasProperty(PTX_FOLDER))
	{
		ptxFolder = data->getProperty(PTX_FOLDER);
		emitPtxFolder(ptxFolder.toStdString());
	}

	if (data->hasProperty(INCLUDE_FOLDER1))
	{
		includeFolder1 = data->getProperty(INCLUDE_FOLDER1);
		emitIncludeFolder(includeFolder1.toStdString(), true);
	}

	if (data->hasProperty(INCLUDE_FOLDER2))
	{
		includeFolder2 = data->getProperty(INCLUDE_FOLDER2);
		emitIncludeFolder(includeFolder2.toStdString(), true);
	}

	if (data->hasProperty(INCLUDE_FOLDER3))
	{
		includeFolder3 = data->getProperty(INCLUDE_FOLDER3);
		emitIncludeFolder(includeFolder3.toStdString(), true);
	}

	if (data->hasProperty(INCLUDE_FOLDER4))
	{
		includeFolder4 = data->getProperty(INCLUDE_FOLDER4);
		emitIncludeFolder(includeFolder4.toStdString(), true);
	}

}

Result CompilerConfig::saveConfig()
{
	DynamicObject* const obj = new DynamicObject;
	obj->setProperty(CUDA_FOLDER, var(cudaFolder));
	obj->setProperty(PTX_FOLDER, var(ptxFolder));
	obj->setProperty(INCLUDE_FOLDER1, var(includeFolder1));
	obj->setProperty(INCLUDE_FOLDER2, var(includeFolder2));
	obj->setProperty(INCLUDE_FOLDER3, var(includeFolder3));
	obj->setProperty(INCLUDE_FOLDER4, var(includeFolder4));

	String configPath = configFolder + File::separator + configName + ".json";

	File f(configPath);
	if (f.existsAsFile())
		f.deleteFile();
	else
		f.create();

	FileOutputStream* const out = f.createOutputStream();
	if (!out)
	{
		return Result::fail("Could not save Compiler config file because of folder write permissions problem!");
	}
	var v(obj);
	JSON::writeToStream(*out, v);

	delete out;
	
	return Result::ok();
}

void CompilerConfig::setCudaFolder(const std::string& folder)
{
	cudaFolder = folder;

	File f(folder);
	if (f.exists())
	{
		File parent = f.getParentDirectory();
		if (parent.exists())
		{
			configName = parent.getFileNameWithoutExtension();
		}
	}
}

void CompilerConfig::setPtxFolder(const std::string& folder)
{
	ptxFolder = folder;
}

void CompilerConfig::addIncludeFolder(const std::string& folder)
{
	if (includeFolder1 == String(INVALID_PATH))
	{
		includeFolder1 = folder;
		return;
	}

	if (includeFolder2 == String(INVALID_PATH))
	{
		includeFolder2 = folder;
		return;
	}

	if (includeFolder3 == String(INVALID_PATH))
	{
		includeFolder3 = folder;
		return;
	}

	if (includeFolder4 == String(INVALID_PATH))
	{
		includeFolder4 = folder;
		return;
	}
}

