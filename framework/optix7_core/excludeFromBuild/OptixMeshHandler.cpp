// This source file was auto-generated by ClassMate++
// Created: 4 Oct 2019 5:48:01 pm
// Copyright (c) 2019, HurleyWorks


// ctor
OptixMeshHandler::OptixMeshHandler ()
{	
	// preallocate some meshes
	// https://devtalk.nvidia.com/default/topic/1063720/optix/dynamic-scene-building/

	uint32_t count = DEFAULT_PREALLOCATED_MESHES_COUNT * WHITTED_RAY_TYPE_COUNT;
	hitgroup_records.resize(count);

	hitgroup_record_base.alloc_and_upload(hitgroup_records);
}

// dtor
OptixMeshHandler::~OptixMeshHandler ()
{	
}

void OptixMeshHandler::onSelectionChange(OptixMeshHandle& mesh)
{
	// client ID is the index into the meshes array
	int slot = mesh->getNode()->getClientID() * WHITTED_RAY_TYPE_COUNT;

	auto it = hitgroup_records.begin();
	std::advance(it, slot);

	if (it != hitgroup_records.end())
	{
		HitGroupRecord& rec = *it;

		if(mesh->getNode()->getState().isSelected())
			rec.data.material_data.pbr.base_color = { 1.0f, 0.5f, 0.0f, 1.0f };
		else
			rec.data.material_data.pbr = OptixMaterialData::Pbr();

		// FIXME instead of uploading the whole thing just change the value in the slot
		hitgroup_record_base.upload(hitgroup_records.data(), hitgroup_records.size());
	}
}

void OptixMeshHandler::addMesh(OptixMeshHandle mesh, OptixShaderBindingTable* const sbt, const OptixPrograms& programs)
{
	if (!radianceHit || !occulsionHit) getPrograms(programs);

	meshes.push_back(mesh);

	// node clientID will be the index in the meshes vector
	RenderableWeakRef weakNode = mesh->getNode();
	if (!weakNode.expired())
		weakNode.lock()->setClientID(meshes.size() - 1);

	HitGroupRecord rec = {};
	OPTIX_CHECK(optixSbtRecordPackHeader(radianceHit->get(), &rec));

	rec.data.geometry_data.type = OptixGeometryData::TRIANGLE_MESH;

	if (mesh->getNode()->isInstance())
	{
		OptixMesh* const source = static_cast<OptixMesh*>(mesh->getNode()->getInstancedFrom()->getUserdata());
		if (source)
		{
			rec.data.geometry_data.triangle_mesh.positions = source->getPositions();
			rec.data.geometry_data.triangle_mesh.normals = source->getNormals();
			rec.data.geometry_data.triangle_mesh.texcoords = source->getTextureCoords();
			rec.data.geometry_data.triangle_mesh.indices = source->getIndices();
		}
	}
	else
	{
		rec.data.geometry_data.triangle_mesh.positions = mesh->getPositions();
		rec.data.geometry_data.triangle_mesh.normals = mesh->getNormals();
		rec.data.geometry_data.triangle_mesh.texcoords = mesh->getTextureCoords();
		rec.data.geometry_data.triangle_mesh.indices = mesh->getIndices();
	}
	
	// just use default material for now
	rec.data.material_data.pbr = OptixMaterialData::Pbr();

	hitgroup_records[nextSlot] = rec;
	
	// the order of adding headers and setting record slots is important
	// these 2 lines have to come *after* the previous slot is filled in 
	OPTIX_CHECK(optixSbtRecordPackHeader(occulsionHit->get(), &rec));
	hitgroup_records[++nextSlot] = rec;

	nextSlot++;

	// FIXME instead of uploading the whole thing just change the value in the slot
	hitgroup_record_base.upload(hitgroup_records.data(), hitgroup_records.size());

	sbt->hitgroupRecordStrideInBytes = static_cast<unsigned int>(hitgroup_record_size);
	sbt->hitgroupRecordCount = static_cast<unsigned int>(getRecordCount());
}

void OptixMeshHandler::getPrograms(const OptixPrograms& programs)
{
	if (!radianceHit)
	{
		auto it = programs.find(radianceHitName);
		if (it != programs.end())
			radianceHit = it->second;

		if (!radianceHit)
			throw std::runtime_error("No radiance hit program found!");
	}

	if (!occulsionHit)
	{
		auto itr = programs.find(occlusionHitName);
		if (itr != programs.end())
			occulsionHit = itr->second;

		if (!occulsionHit)
			throw std::runtime_error("No occulsion hit program found!");
	}
}
