
// This source file was auto-generated by ClassMate++
// Created: 4 Oct 2019 5:48:01 pm
// Copyright (c) 2019, HurleyWorks


// ctor
OptixMeshHandler::OptixMeshHandler ()
{	
	preallocate();
}

// dtor
OptixMeshHandler::~OptixMeshHandler ()
{	
	hitgroup_records.clear();
	hitgroup_record_base.free();
}

void OptixMeshHandler::onSelectionChange(OptixMeshHandle& mesh)
{
	// client ID is the index into the meshes array
	int slot = mesh->getNode()->getClientID() * WHITTED_RAY_TYPE_COUNT;

	auto it = hitgroup_records.begin();
	std::advance(it, slot);

	if (it != hitgroup_records.end())
	{
		HitGroupRecord& rec = *it;

		if (mesh->getNode()->getState().isSelected())
			rec.data.material_data.pbr.base_color = { 1.0f, 0.5f, 0.0f, 1.0f };
		else
			rec.data.material_data.pbr = mesh->getMaterial(0);

		hitgroup_record_base.uploadSlot(&hitgroup_records[slot], slot, 1);
	}
}

void OptixMeshHandler::addMesh(OptixMeshHandle mesh, OptixShaderBindingTable* const sbt, const OptixPrograms& programs)
{
	if (!radianceHit || !occulsionHit) getPrograms(programs);

	if (meshes.size() >= DEFAULT_PREALLOCATED_MESHES_COUNT)
	{
		throw std::runtime_error("Reached preallocated limit!");
	}

	meshes.push_back(mesh);

	// node clientID will be the index in the meshes vector
	RenderableWeakRef weakNode = mesh->getNode();
	if (!weakNode.expired())
		weakNode.lock()->setClientID(meshes.size() - 1);

	HitGroupRecord rec = {};
	OPTIX_CHECK(optixSbtRecordPackHeader(radianceHit->get(), &rec));

	rec.data.geometry_data.type = OptixGeometryData::TRIANGLE_MESH;

	if (mesh->isInstance())
	{
		OptixMesh* const source = static_cast<OptixMesh*>(mesh->getNode()->getInstancedFrom()->getUserdata());
		if (source)
		{
			rec.data.geometry_data.triangle_mesh.positions = source->getPositions();
			rec.data.geometry_data.triangle_mesh.normals = source->getNormals();
			rec.data.geometry_data.triangle_mesh.texcoords = source->getTextureCoords();
			rec.data.geometry_data.triangle_mesh.indices = source->getIndices();

			rec.data.material_data.pbr = source->getMaterial(0);
		}
	}
	else
	{
		rec.data.geometry_data.triangle_mesh.positions = mesh->getPositions();
		rec.data.geometry_data.triangle_mesh.normals = mesh->getNormals();
		rec.data.geometry_data.triangle_mesh.texcoords = mesh->getTextureCoords();
		rec.data.geometry_data.triangle_mesh.indices = mesh->getIndices();

		rec.data.material_data.pbr = mesh->getMaterial(0);
	}
	
	
	
	hitgroup_records[nextSlot] = rec;
	hitgroup_record_base.uploadSlot(&hitgroup_records[nextSlot], nextSlot, 1);
	++nextSlot;

	// the order of adding headers and setting record slots is important
	// these 2 lines have to come *after* the previous slot is filled in 
	OPTIX_CHECK(optixSbtRecordPackHeader(occulsionHit->get(), &rec));
	hitgroup_records[nextSlot] = rec;
	hitgroup_record_base.uploadSlot(&hitgroup_records[nextSlot], nextSlot, 1);
	++nextSlot;
	
	sbt->hitgroupRecordStrideInBytes = static_cast<unsigned int>(hitgroup_record_size);
	sbt->hitgroupRecordCount = static_cast<unsigned int>(getRecordCount());
}

void OptixMeshHandler::getPrograms(const OptixPrograms& programs)
{
	if (!radianceHit)
	{
		auto it = programs.find(radianceHitName);
		if (it != programs.end())
			radianceHit = it->second;

		if (!radianceHit)
			throw std::runtime_error("No radiance hit program found!");
	}

	if (!occulsionHit)
	{
		auto itr = programs.find(occlusionHitName);
		if (itr != programs.end())
			occulsionHit = itr->second;

		if (!occulsionHit)
			throw std::runtime_error("No occulsion hit program found!");
	}
}

void OptixMeshHandler::preallocate()
{
	// preallocate some meshes
	// https://devtalk.nvidia.com/default/topic/1063720/optix/dynamic-scene-building/

	uint32_t count = DEFAULT_PREALLOCATED_MESHES_COUNT * WHITTED_RAY_TYPE_COUNT;
	hitgroup_records.resize(count);

	hitgroup_record_base.alloc(count);
	hitgroup_record_base.upload(hitgroup_records.data());
}
