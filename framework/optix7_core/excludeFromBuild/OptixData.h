// This header file was auto-generated by ClassMate++
// Created: 18 Aug 2019 4:00:14 pm
// Copyright (c) 2019, HurleyWorks

#pragma once

// FIXME surely this is not going to be common for all projects
struct Params
{
	uchar4* image;
	uint32_t               image_width;
	uint32_t               image_height;
	int32_t                origin_x;
	int32_t                origin_y;
	OptixTraversableHandle handle;
};


using ContextHandle = std::shared_ptr<class OptixContext>;

class OptixContext
{

 public:
	static ContextHandle create(const OptixDeviceContextOptions & options) { return std::make_shared<OptixContext>(options); }

 public:
	OptixContext(const OptixDeviceContextOptions& options)
	{
		try
		{
			// Initialize CUDA
			CUDA_CHECK(cudaFree(0));

			CUcontext cuCtx = 0;  // zero means take the current context
			OPTIX_CHECK(optixInit());
			OPTIX_CHECK(optixDeviceContextCreate(cuCtx, &options, &context));
		}
		catch (std::exception& e)
		{
			LOG(CRITICAL) << "Caught exception: " << e.what();

			if (context)
				OPTIX_CHECK(optixDeviceContextDestroy(context));

			context = nullptr;
	
		}
	}
	~OptixContext()
	{
		LOG(DBUG) << _FN_;

		try
		{
			if(context)
				OPTIX_CHECK(optixDeviceContextDestroy(context));
		}
		catch (std::exception& e)
		{
			LOG(CRITICAL) << "Caught exception: " << e.what();
		}
	}

	OptixDeviceContext get()
	{
		if (context)
			return context;
		else
			throw std::runtime_error("OptixDeviceContext is invalid(nullptr)");
	}

	OptixDeviceContext operator -> ()
	{
		if (context)
			return context;
		else
			throw std::runtime_error("OptixDeviceContext is invalid(nullptr)");
	}


 private:
	OptixDeviceContext context = nullptr;
};

template <typename T = char>
class CuBuffer
{
public:
	CuBuffer(size_t count = 0) { alloc(count); }
	~CuBuffer() { free(); }
	void alloc(size_t count)
	{
		free();
		m_allocCount = m_count = count;
		if (m_count)
		{
			CUDA_CHECK(cudaMalloc(&m_ptr, m_allocCount * sizeof(T)));
		}
	}
	void allocIfRequired(size_t count)
	{
		if (count <= m_count)
		{
			m_count = count;
			return;
		}
		alloc(count);
	}
	CUdeviceptr get() const { return reinterpret_cast<CUdeviceptr>(m_ptr); }
	CUdeviceptr get(size_t index) const { return reinterpret_cast<CUdeviceptr>(m_ptr + index); }
	void        free()
	{
		m_count = 0;
		m_allocCount = 0;
		CUDA_CHECK(cudaFree(m_ptr));
		m_ptr = nullptr;
	}
	CUdeviceptr release()
	{
		CUdeviceptr current = reinterpret_cast<CUdeviceptr>(m_ptr);
		m_count = 0;
		m_allocCount = 0;
		m_ptr = nullptr;
		return current;
	}
	void upload(const T* data)
	{
		CUDA_CHECK(cudaMemcpy(m_ptr, data, m_count * sizeof(T), cudaMemcpyHostToDevice));
	}

	void download(T* data) const
	{
		CUDA_CHECK(cudaMemcpy(data, m_ptr, m_count * sizeof(T), cudaMemcpyDeviceToHost));
	}
	void downloadSub(size_t count, size_t offset, T* data) const
	{
		assert(count + offset < m_allocCount);
		CUDA_CHECK(cudaMemcpy(data, m_ptr + offset, count * sizeof(T), cudaMemcpyDeviceToHost));
	}
	size_t count() const { return m_count; }
	size_t reservedCount() const { return m_allocCount; }
	size_t byteSize() const { return m_allocCount * sizeof(T); }

private:
	size_t m_count = 0;
	size_t m_allocCount = 0;
	T* m_ptr = nullptr;
};