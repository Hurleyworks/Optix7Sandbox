// This header file was auto-generated by ClassMate++
// Created: 12 Sep 2019 6:29:23 am
// Copyright (c) 2019, HurleyWorks

#pragma once

using sabi::RenderableWeakRef;
using sabi::RenderableNode;
using sabi::MeshBuffersHandle;
using Eigen::Matrix4f;

using OptixMeshHandle = std::shared_ptr<class OptixMesh>;

class OptixMesh
{
 
 public:
	 static OptixMeshHandle create(RenderableNode& node) { return std::make_shared<OptixMesh>(node); }

 public:
	OptixMesh (RenderableNode& node);
	~OptixMesh ();

	void init(ContextHandle& context);

	bool isInstance() const { return weakNode.expired() ? false : weakNode.lock()->isInstance(); }
	ItemID getID() { return weakNode.expired() ? INVALID_ID : weakNode.lock()->getID(); }
	const RenderableNode& getNode() const { return weakNode.expired() ? nullptr : weakNode.lock(); }
	RenderableNode getNode() { return weakNode.expired() ? nullptr : weakNode.lock(); }
	OptixTraversableHandle getGAS() const { return weakNode.expired() ? 0 : GAS; }

	Matrix43f getWorldTransform()
	{
		if (weakNode.expired()) return Matrix43f().setIdentity();

		Matrix4f m = weakNode.lock()->getSpaceTime().worldTransform.matrix();
		m.transposeInPlace(); // must transpose for Optix

		// pull out a 4 x 3 sub matrix
		return m.block<4,3>( 0, 0);
	}

	const OptixBufferViewUint32& getIndices() const { return indices; }
	const OptixBufferView3f& getPositions() const { return positions; }
	const OptixBufferView3f& getNormals() const { return normals; }
	const OptixBufferView2f& getTextureCoords() const { return texcoords; }
	const int32_t getMaterialIndex() const { return materialIndex; }
	OptixMaterialData::Pbr getMaterial(size_t index)
	{
		if(!materials.size() ) return OptixMaterialData::Pbr();

		auto it = materials.begin();
		std::advance(it, index);

		return it != materials.end() ? *it : OptixMaterialData::Pbr();
	}
 private:
	RenderableWeakRef weakNode;
	OptixTraversableHandle GAS = 0;
	std::vector<OptixMaterialData::Pbr>  materials;
	OptixBufferViewUint32 indices;
	OptixBufferView3f positions;
	OptixBufferView3f normals;
	OptixBufferView2f texcoords;
	int32_t materialIndex = INVALID_INDEX;

	CUDABuffer asBuffer;

	size_t byteOffset = 0;
	CUdeviceptr deviceBuffer = 0;
	
	std::vector<cudaTextureObject_t> samplers;
	std::vector<cudaArray_t> images;

	void createBuffer(const uint64_t buf_size, const void* data);
	void createGAS(ContextHandle& context);
	void createMaterials(MeshBuffersHandle& mesh);
	void addImage( const int32_t width,
				   const int32_t height,
				   const int32_t bits_per_component,
				   const int32_t num_components,
				   const void* data
	);

	void addSampler(cudaTextureAddressMode address_s,
		            cudaTextureAddressMode address_t,
		            cudaTextureFilterMode  filter_mode,
		            const int32_t image_idx
	);

}; // end class OptixMesh

using SceneMeshes = std::vector< OptixMeshHandle>;