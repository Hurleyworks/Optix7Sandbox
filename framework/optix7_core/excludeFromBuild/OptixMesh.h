// This header file was auto-generated by ClassMate++
// Created: 12 Sep 2019 6:29:23 am
// Copyright (c) 2019, HurleyWorks

#pragma once

using sabi::RenderableWeakRef;
using sabi::RenderableNode;
using Eigen::Matrix4f;

using OptixMeshHandle = std::shared_ptr<class OptixMesh>;

class OptixMesh
{
 
 public:
	 static OptixMeshHandle create(RenderableNode& node) { return std::make_shared<OptixMesh>(node); }

 public:
	OptixMesh (RenderableNode& node);
	~OptixMesh ();

	void init(ContextHandle& context);
	ItemID getID() { return weakNode.expired() ? INVALID_ID : weakNode.lock()->getID(); }

	OptixTraversableHandle getGAS() const { return weakNode.expired() ? 0 : GAS; }
	Matrix43f getWorldTransform()
	{
		if (weakNode.expired()) return Matrix43f().setIdentity();

		Matrix4f m = weakNode.lock()->getSpaceTime().worldTransform.matrix();
		m.transposeInPlace(); // must transpose for Optix

		// pull out a 4 x 3 sub matrix
		return m.block<4,3>( 0, 0);
	}

	// FIXME make accessors
	OptixBufferViewUint32 indices;
	OptixBufferView3f positions;
	OptixBufferView3f normals;
	OptixBufferView2f texcoords;
	int32_t materialIndex = INVALID_INDEX;

 private:
	RenderableWeakRef weakNode;
	OptixTraversableHandle GAS = 0;

	// from Ingo Wald tutorial
	CUDABuffer asBuffer;

	// from OptixSDK meshViewer sample
	size_t byteOffset = 0;
	CUdeviceptr deviceBuffer = 0;
	
	void createBuffer(const uint64_t buf_size, const void* data);
	void createGAS(ContextHandle& context);

}; // end class OptixMesh

using SceneMeshes = std::vector< OptixMeshHandle>;