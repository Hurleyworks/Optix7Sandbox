// This header file was auto-generated by ClassMate++
// Created: 12 Sep 2019 6:29:23 am
// Copyright (c) 2019, HurleyWorks

#pragma once

using sabi::RenderableWeakRef;
using sabi::RenderableNode;
using Eigen::Matrix4f;

using OptixMeshHandle = std::shared_ptr<class OptixMesh>;

class OptixMesh
{
 
 public:
	 static OptixMeshHandle create(RenderableNode& node) { return std::make_shared<OptixMesh>(node); }

 public:
	OptixMesh (RenderableNode& node);
	~OptixMesh ();

	void init(ContextHandle& context);

	bool isInstances() const { return weakNode.expired() ? false : weakNode.lock()->isInstance(); }
	ItemID getID() { return weakNode.expired() ? INVALID_ID : weakNode.lock()->getID(); }
	const RenderableNode& getNode() const { return weakNode.expired() ? nullptr : weakNode.lock(); }
	RenderableNode getNode() { return weakNode.expired() ? nullptr : weakNode.lock(); }
	OptixTraversableHandle getGAS() const { return weakNode.expired() ? 0 : GAS; }

	Matrix43f getWorldTransform()
	{
		if (weakNode.expired()) return Matrix43f().setIdentity();

		Matrix4f m = weakNode.lock()->getSpaceTime().worldTransform.matrix();
		m.transposeInPlace(); // must transpose for Optix

		// pull out a 4 x 3 sub matrix
		return m.block<4,3>( 0, 0);
	}

	const OptixBufferViewUint32& getIndices() const { return indices; }
	const OptixBufferView3f& getPositions() const { return positions; }
	const OptixBufferView3f& getNormals() const { return normals; }
	const OptixBufferView2f& getTextureCoords() const { return texcoords; }
	const int32_t getMaterialIndex() const { return materialIndex; }
	
 private:
	RenderableWeakRef weakNode;
	OptixTraversableHandle GAS = 0;

	OptixBufferViewUint32 indices;
	OptixBufferView3f positions;
	OptixBufferView3f normals;
	OptixBufferView2f texcoords;
	int32_t materialIndex = INVALID_INDEX;

	// from Ingo Wald tutorial
	CUDABuffer asBuffer;

	// from OptixSDK meshViewer sample
	size_t byteOffset = 0;
	CUdeviceptr deviceBuffer = 0;
	
	void createBuffer(const uint64_t buf_size, const void* data);
	void createGAS(ContextHandle& context);

}; // end class OptixMesh

using SceneMeshes = std::vector< OptixMeshHandle>;