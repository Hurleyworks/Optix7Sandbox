#include "OptixAccel.h"

// This source file was auto-generated by ClassMate++
// Created: 12 Sep 2019 6:29:23 am
// Copyright (c) 2019, HurleyWorks


// ctor
OptixAccel::OptixAccel ()
{	
	
}

// dtor
OptixAccel::~OptixAccel ()
{	
	try
	{
		if (deviceIAS)
			CUDA_CHECK(cudaFree(reinterpret_cast<void*>(deviceIAS)));
	}
	catch (const std::runtime_error& e)
	{
		LOG(CRITICAL) << e.what();
	}
	catch (...)
	{
		LOG(CRITICAL) << "Caught unknow exception";
	}
}

void OptixAccel::rebuildSceneAccel(ContextHandle& context,const SceneMeshes& meshes, bool justUpdate)
{
	if (!meshes.size()) return;

	if (justUpdate && meshes.size())
	{
		//if (!meshes.size()) return;

		//std::cout << "-------updating" << std::endl;
		// When updating an existing acceleration structure, only the device 
		// pointersand /or their buffer content may be changed.In particular, 
		// it is invalid to change the number of build inputs, the build input types, 
		// build ﬂags, traversable handles for instances(for IAS), or the number of vertices,
		// indices, AABBs, instances, SBT records or motion keys; 
		// changes to any of these things may result in undeﬁned behavior, including GPU faults.

		accelOptions.operation = OPTIX_BUILD_OPERATION_UPDATE;

		updateInstanceTransforms(meshes);

		instanceInput.type = OPTIX_BUILD_INPUT_TYPE_INSTANCES;
		instanceInput.instanceArray.instances = deviceInstances.get();

		OPTIX_CHECK(optixAccelComputeMemoryUsage(
			context->get(),
			&accelOptions,
			&instanceInput,
			1, // num build inputs
			&IASbufferSizes
		));

		CUDA_CHECK(cudaMalloc(
			reinterpret_cast<void**>(&deviceTempBuffer),
			IASbufferSizes.tempSizeInBytes
		));

		OPTIX_CHECK(optixAccelBuild(
			context->get(),
			nullptr,                  // CUDA stream
			&accelOptions,
			&instanceInput,
			1,                  // num build inputs
			deviceTempBuffer,
			IASbufferSizes.tempSizeInBytes,
			deviceIAS,
			IASbufferSizes.outputSizeInBytes,
			&IAS,
			nullptr,            // emitted property list
			0                   // num emitted properties
		));

		CUDA_CHECK(cudaFree(reinterpret_cast<void*>(deviceTempBuffer)));
		return;
	}

	// out with the old buffer
	if (deviceIAS)
		CUDA_CHECK(cudaFree(reinterpret_cast<void*>(deviceIAS)));

	unsigned int sbtOffset = 0;
	for (size_t i = 0; i < meshes.size(); ++i)
	{
		auto& mesh = meshes[i];
		auto& optixInstance = optixInstances[i];
		
		optixInstance.flags = OPTIX_INSTANCE_FLAG_NONE;
		optixInstance.instanceId = static_cast<unsigned int>(mesh->getNode()->getClientID());
		optixInstance.sbtOffset = sbtOffset;
		optixInstance.visibilityMask = 1;
		optixInstance.traversableHandle = mesh->getGAS();
		memcpy(optixInstance.transform, mesh->getWorldTransform().data(), sizeof(float) * 12);

		// FIXME what should this really be???
		const int FIXME = 1; 
		sbtOffset += FIXME * WHITTED_RAY_TYPE_COUNT;
	}

	if( meshes.size())
		deviceInstances.upload(optixInstances.data());

	// not setting this here was the cause of mystery crashing
	accelOptions.buildFlags = OPTIX_BUILD_FLAG_ALLOW_UPDATE; 
	accelOptions.operation = OPTIX_BUILD_OPERATION_BUILD;

	instanceInput.type = OPTIX_BUILD_INPUT_TYPE_INSTANCES;
	instanceInput.instanceArray.instances = deviceInstances.get();
	instanceInput.instanceArray.numInstances = static_cast<unsigned int>(instanceCount);

	OPTIX_CHECK(optixAccelComputeMemoryUsage(
		context->get(),
		&accelOptions,
		&instanceInput,
		1, // num build inputs
		&IASbufferSizes
	));

	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&deviceTempBuffer),
		IASbufferSizes.tempSizeInBytes
	));
	CUDA_CHECK(cudaMalloc(
		reinterpret_cast<void**>(&deviceIAS),
		IASbufferSizes.outputSizeInBytes
	));

	OPTIX_CHECK(optixAccelBuild(
		context->get(),
		nullptr,                  // CUDA stream
		&accelOptions,
		&instanceInput,
		1,                  // num build inputs
		deviceTempBuffer,
		IASbufferSizes.tempSizeInBytes,
		deviceIAS,
		IASbufferSizes.outputSizeInBytes,
		&IAS,
		nullptr,            // emitted property list
		0                   // num emitted properties
	));

	CUDA_CHECK(cudaFree(reinterpret_cast<void*>(deviceTempBuffer)));
}

void OptixAccel::updateInstanceTransforms(const SceneMeshes& meshes)
{
	for (size_t i = 0; i < meshes.size(); ++i)
	{
		auto& mesh = meshes[i];
		auto& optixInstance = optixInstances[i];
		
		memcpy(optixInstance.transform, mesh->getWorldTransform().data(), sizeof(float) * 12);
	}

	// sync new transforms to device
	deviceInstances.upload(optixInstances.data());
}

void OptixAccel::preallocate(ContextHandle& context)
{
	IAS = 0;

	// out with the old buffer
	if (deviceIAS)
	{
		CUDA_CHECK(cudaFree(reinterpret_cast<void*>(deviceIAS)));
		deviceIAS = 0;
	}
		
	optixInstances.clear();
	deviceInstances.free();

	// preallocate some meshes
	// https://devtalk.nvidia.com/default/topic/1063720/optix/dynamic-scene-building/

	optixInstances.resize(instanceCount);

	deviceInstances.alloc(instanceCount);
	
	for (auto inst : optixInstances)
	{
		memset(&inst, 0, sizeof(OptixInstance));
	}

	deviceInstances.upload(optixInstances.data());
}