
// This source file was auto-generated by ClassMate++
// Created: 18 Aug 2019 4:00:14 pm
// Copyright (c) 2019, HurleyWorks

using juce::String;
using juce::File;
using juce::StringArray;
using mace::FileServices;

// ctor
OptixEngine::OptixEngine (const PropertyService& properties,const OptixConfig& config)
	: properties(properties),
	  config(config)
{	
	context = OptixContext::create(config.options.context_options);
	
	// gather all the standard entry function name prefixes
	programPrefixes.add(RAYGEN_FUNCTION_PREFIX);
	programPrefixes.add(INTERSECTION_FUNCTION_PREFIX);
	programPrefixes.add(ANY_HIT_FUNCTION_PREFIX);
	programPrefixes.add(CLOSEST_HIT_FUNCTION_PREFIX);
	programPrefixes.add(MISS_FUNCTION_PREFIX);
	programPrefixes.add(DIRECT_CALLABLE__FUNCTION_PREFIX);
	programPrefixes.add(CONTINUATION_FUNCTION_PREFIX);
	programPrefixes.add(EXCEPTION_FUNCTION_PREFIX);
}

// dtor
OptixEngine::~OptixEngine ()
{	
	try
	{
		CUDA_CHECK(cudaFree(reinterpret_cast<void*>(sbt.raygenRecord)));
		CUDA_CHECK(cudaFree(reinterpret_cast<void*>(sbt.missRecordBase)));
		CUDA_CHECK(cudaFree(reinterpret_cast<void*>(sbt.hitgroupRecordBase)));

		// delete program groups before context is destroyed
		config.programs.hitgroupProgs.clear();
		config.programs.missProgs.clear();
		config.programs.raygenProgs.clear();

		// delete the modules before the context is destroyed
		modules.clear();
	}
	catch (std::exception& e)
	{
		LOG(CRITICAL) << e.what();
	}
	catch (...)
	{
		LOG(CRITICAL) << "Caught unknown exception";
	}
}

ProgramGroupHandle OptixEngine::createRaygenPrograms(ModuleHandle& module, const String& functionName)
{
	config.desc.raygen_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_RAYGEN;

	if (module && functionName != String::empty)
	{
		config.desc.raygen_prog_group_desc.raygen.module = module->get();
		config.desc.raygen_prog_group_desc.raygen.entryFunctionName = functionName.getCharPointer().getAddress();
	}
	else 
		return nullptr;

	ProgramGroupHandle handle = OptiXProgramGroup::create(config.options.program_group_options, config.desc.raygen_prog_group_desc);
	handle->makeGroup(context);

	return handle;
}

ProgramGroupHandle OptixEngine::createMissPrograms(ModuleHandle& module, const String& functionName)
{
	config.desc.miss_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_MISS;

	if (module && functionName != String::empty)
	{
		config.desc.miss_prog_group_desc.miss.module = module->get();
		config.desc.miss_prog_group_desc.miss.entryFunctionName = functionName.getCharPointer().getAddress();
	}
	else
		return nullptr;

	ProgramGroupHandle handle = OptiXProgramGroup::create(config.options.program_group_options, config.desc.miss_prog_group_desc);
	handle->makeGroup(context);

	return handle;
}

ProgramGroupHandle OptixEngine::createHitgroupPrograms(const HitGroupData& hitgroupData)
{
	config.desc.hitgroup_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP;
	config.desc.hitgroup_prog_group_desc.hitgroup.moduleCH = nullptr;
	config.desc.hitgroup_prog_group_desc.hitgroup.entryFunctionNameCH = nullptr;
	config.desc.hitgroup_prog_group_desc.hitgroup.moduleAH = nullptr;
	config.desc.hitgroup_prog_group_desc.hitgroup.entryFunctionNameAH = nullptr;
	config.desc.hitgroup_prog_group_desc.hitgroup.moduleIS = nullptr;
	config.desc.hitgroup_prog_group_desc.hitgroup.entryFunctionNameIS = nullptr;

	for (auto const & pair : hitgroupData)
	{
		// check to make sure the incoming modules and function names are in our program database
		bool foundModule = false;

		// search for the incoming module
		for (auto mods : modules)
		{
			if (pair.first == mods.second)
			{
				foundModule = true;

				// find the incoming function name in the program database
				// list of function names for this module
				auto itr = programDB.find(mods.first);
				if (itr != programDB.end())
				{
					const PtxData& ptxData = itr->second;
					int index = ptxData.functionNames.indexOf(pair.second);
					if (index == -1)
					{
						std::stringstream ss;
						ss << "Could not find function " << pair.second.toStdString() << " in ptx file:  " << mods.first;
						throw std::runtime_error(ss.str());
					}
				}
				break;
			}
		}

		if (!foundModule)
			throw std::runtime_error("Could not find hit module containig " + pair.second.toStdString());

		if (pair.second.startsWith(CLOSEST_HIT_FUNCTION_PREFIX))
		{
			config.desc.hitgroup_prog_group_desc.hitgroup.moduleCH = pair.first->get();
			config.desc.hitgroup_prog_group_desc.hitgroup.entryFunctionNameCH = pair.second.getCharPointer().getAddress();
			continue;
		}

		if (pair.second.startsWith(ANY_HIT_FUNCTION_PREFIX))
		{
			config.desc.hitgroup_prog_group_desc.hitgroup.moduleAH = pair.first->get();
			config.desc.hitgroup_prog_group_desc.hitgroup.entryFunctionNameAH = pair.second.getCharPointer().getAddress();
			continue;
		}

		if (pair.second.startsWith(INTERSECTION_FUNCTION_PREFIX))
		{
			config.desc.hitgroup_prog_group_desc.hitgroup.moduleIS = pair.first->get();
			config.desc.hitgroup_prog_group_desc.hitgroup.entryFunctionNameIS = pair.second.getCharPointer().getAddress();
			continue;
		}
	}

	ProgramGroupHandle handle = OptiXProgramGroup::create(config.options.program_group_options, config.desc.hitgroup_prog_group_desc);
	handle->makeGroup(context);

	return handle;
}

ModuleHandle OptixEngine::createModule(PtxData& data)
{
	ModuleHandle handle = OptiXModule::create(config.options.pipeline_compile_options, config.options.module_compile_options);
	if (!handle)
		throw std::runtime_error("ModuleHandle creation failed!");

	handle->creatFromPTx(context, data.ptxStr.toStdString());

	return handle;
}

String OptixEngine::extractProgramFunctionName(const String& line, const String& prefix)
{
	String func = line.fromFirstOccurrenceOf(prefix, true, false);

	// find the first left parenthesis
	int leftParan = func.indexOfChar('(');
	if (leftParan == -1) return String::empty;

	return func.substring(0, leftParan);
}

void OptixEngine::createProgramDatabase()
{
	ScopedStopWatch sw(_FN_);

	std::string resourceFolder = properties.renderProps->getVal<std::string>(RenderKey::ResourceFolder);
	File f(resourceFolder);
	if (!f.exists())
		throw std::runtime_error("No resource folder found at " + resourceFolder);

	String ptxFolder = resourceFolder + "/ptx";
	StringArray ptxFiles;
	String wildCard("*.ptx");
	FileServices::getFiles(ptxFolder, ptxFiles, wildCard);

	String ptxStr = String::empty;

	for (auto ptx : ptxFiles)
	{
		File f(ptx);
		if (!f.existsAsFile()) continue;

		String moduleName = f.getFileNameWithoutExtension();
		StringArray functionNames;

		StringArray lines;
		lines.addLines(f.loadFileAsString());

		for (auto line : lines)
		{
			// skip comments
			if (line.startsWith("//")) continue;

			// look for program function names
			for (auto prefix : programPrefixes)
			{
				if (line.contains(prefix))
				{
					String funcName = extractProgramFunctionName(line, prefix);
					if (funcName != String::empty)
					{
						funcName = funcName.trim();
						LOG(DBUG) << "Found " << funcName << " in " <<  f.getFileName();
						functionNames.add(funcName);
					}
					continue;
				}
			}
		}

		if (functionNames.size())
		{
			PtxData data;
			data.ptxStr = lines.joinIntoString("\n");
			data.functionNames = functionNames;
			programDB.insert(std::make_pair(moduleName, data));
		}
	}
}

void OptixEngine::createProgramGroups(const json& groups)
{
	// one module per ptx file 
	for (auto it : programDB)
	{
		// create a module from the Ptx data
		ModuleHandle module = createModule(it.second);
		modules.insert(std::make_pair(it.first, module));
	}

	for (auto const& i : json::iterator_wrapper(groups))
	{
		json j = i.value();
		createProgramGroup(j);
	}
}

void OptixEngine::createProgramGroup(const json& j)
{
	if (!j["kind"].is_number_integer()) return;
	
	int kind = j["kind"];
	
	switch (kind)
	{
		case OPTIX_PROGRAM_GROUP_KIND_RAYGEN:
		{
			String key = j["module"];
			
			auto it = modules.find(key);
			if (it != modules.end())
			{
				String funcName = j["entryFunctionName"];
				ProgramGroupHandle handle = createRaygenPrograms(it->second, funcName);
				if (handle)
					config.programs.raygenProgs.push_back(handle);
			}
			break;
		}

		case OPTIX_PROGRAM_GROUP_KIND_MISS:
		{
			String key = j["module"];

			auto it = modules.find(key);
			if (it != modules.end())
			{
				String funcName = j["entryFunctionName"];
				ProgramGroupHandle handle = createMissPrograms(it->second, funcName);
				if (handle)
					config.programs.missProgs.push_back(handle);
			}
			break;
		}

		case OPTIX_PROGRAM_GROUP_KIND_HITGROUP:
		{
			HitGroupData groupData;

			ModuleHandle CH = nullptr;
			ModuleHandle AH = nullptr;
			ModuleHandle IS = nullptr;
			String funcCH = "nullptr";
			String funcAH = "nullptr";
			String funcIS = "nullptr";

			if (j["moduleCH"].is_string())
			{
				String key = j["moduleCH"];
				auto it = modules.find(key);
				if (it != modules.end())
					CH = it->second;
			}

			if (j["moduleAH"].is_string())
			{
				String key = j["moduleAH"];
				auto it = modules.find(key);
				if (it != modules.end())
					AH = it->second;
			}
			if (j["moduleIS"].is_string())
			{
				String key = j["moduleIS"];
				auto it = modules.find(key);
				if (it != modules.end())
					IS = it->second;
			}

			if (CH && j["entryFunctionNameCH"].is_string())
			{
				String funcName = j["entryFunctionNameCH"];
				HitGroupPair data = std::make_pair(CH, funcName);
				groupData.push_back(data);
			}

			if (AH && j["entryFunctionNameAH"].is_string())
			{
				String funcName = j["entryFunctionNameAH"];
				HitGroupPair data = std::make_pair(AH, funcName);
				groupData.push_back(data);
			}

			if (IS && j["entryFunctionNameIS"].is_string())
			{
				String funcName = j["entryFunctionNameIS"];
				HitGroupPair data = std::make_pair(IS, funcName);
				groupData.push_back(data);
			}

			ProgramGroupHandle handle = createHitgroupPrograms(groupData);
			if (handle)
				config.programs.hitgroupProgs.push_back(handle);
			
			break;
		}
			
		
		case OPTIX_PROGRAM_GROUP_KIND_EXCEPTION:
			break;
		
		case OPTIX_PROGRAM_GROUP_KIND_CALLABLES:
			break;
	}
}

PipelineHandle OptixEngine::createPipeline(const json& groups)
{
	createProgramDatabase();
	createProgramGroups(groups);

	std::vector<OptixProgramGroup> programGroups;

	for (auto prog : config.programs.raygenProgs)
		programGroups.push_back(prog->get());

	for (auto prog : config.programs.missProgs)
		programGroups.push_back(prog->get());

	for (auto prog : config.programs.hitgroupProgs)
		programGroups.push_back(prog->get());

	if (!programGroups.size())
		throw std::runtime_error("No program groups avaialble for creating pipeline");

	LOG(DBUG) << "Linking " << programGroups.size() << " program groups";

	PipelineHandle handle = ProgramPipeline::create(config.options.pipeline_compile_options, config.options.pipeline_link_options, programGroups);
	if(handle)
		handle->link(context);

	return handle;
}