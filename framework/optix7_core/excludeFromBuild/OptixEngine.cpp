#include "OptixEngine.h"


// This source file was auto-generated by ClassMate++
// Created: 18 Aug 2019 4:00:14 pm
// Copyright (c) 2019, HurleyWorks

using juce::String;
using juce::File;
using juce::StringArray;
using mace::FileServices;

// ctor
OptixEngine::OptixEngine (const PropertyService& properties,const OptixConfig& config)
	: properties(properties),
	  config(config)
{	
	context = OptixContext::create(config.options.context_options);
	
	// gather all the standard function name prefixes
	programPrefixes.add(RAYGEN_FUNCTION_PREFIX);
	programPrefixes.add(INTERSECTION_FUNCTION_PREFIX);
	programPrefixes.add(ANY_HIT_FUNCTION_PREFIX);
	programPrefixes.add(CLOSEST_HIT_FUNCTION_PREFIX);
	programPrefixes.add(MISS_FUNCTION_PREFIX);
	programPrefixes.add(DIRECT_CALLABLE__FUNCTION_PREFIX);
	programPrefixes.add(CONTINUATION_FUNCTION_PREFIX);
	programPrefixes.add(EXCEPTION_FUNCTION_PREFIX);
}

// dtor
OptixEngine::~OptixEngine ()
{	
	try
	{
		CUDA_CHECK(cudaFree(reinterpret_cast<void*>(sbt.raygenRecord)));
		CUDA_CHECK(cudaFree(reinterpret_cast<void*>(sbt.missRecordBase)));
		CUDA_CHECK(cudaFree(reinterpret_cast<void*>(sbt.hitgroupRecordBase)));

		// delete the modules before the context is destroyed
		modules.clear();
	}
	catch (std::exception& e)
	{
		LOG(CRITICAL) << e.what();
	}
	catch (...)
	{
		LOG(CRITICAL) << "Caught unknown exception";
	}
}

ProgramGroupHandle OptixEngine::createRaygenPrograms(ModuleHandle& module, const String& functionName)
{
	config.desc.raygen_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_RAYGEN;

	if (module && functionName != String::empty)
	{
		config.desc.raygen_prog_group_desc.raygen.module = module->get();
		config.desc.raygen_prog_group_desc.raygen.entryFunctionName = functionName.getCharPointer().getAddress();
	}

	ProgramGroupHandle handle = OptiXProgramGroup::create(config.options.program_group_options, config.desc.raygen_prog_group_desc);
	handle->makeGroup(context);

	return handle;
}

ProgramGroupHandle OptixEngine::createMissPrograms(ModuleHandle& module, const String& functionName)
{
	config.desc.miss_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_MISS;

	if (module && functionName != String::empty)
	{
		config.desc.miss_prog_group_desc.miss.module = module->get();
		config.desc.miss_prog_group_desc.miss.entryFunctionName = functionName.getCharPointer().getAddress();
	}

	ProgramGroupHandle handle = OptiXProgramGroup::create(config.options.program_group_options, config.desc.miss_prog_group_desc);
	handle->makeGroup(context);

	return handle;
}

ProgramGroupHandle OptixEngine::createHitgroupPrograms(ModuleHandle& module, const StringArray& functionNames)
{
	config.desc.hitgroup_prog_group_desc.kind = OPTIX_PROGRAM_GROUP_KIND_HITGROUP;
	for (auto fn : functionNames)
	{
		if (fn.startsWith(CLOSEST_HIT_FUNCTION_PREFIX))
		{
			config.desc.hitgroup_prog_group_desc.hitgroup.moduleCH = module->get();
			config.desc.hitgroup_prog_group_desc.hitgroup.entryFunctionNameCH = fn.getCharPointer().getAddress();
			continue;
		}

		if (fn.startsWith(ANY_HIT_FUNCTION_PREFIX))
		{
			config.desc.hitgroup_prog_group_desc.hitgroup.moduleAH = module->get();
			config.desc.hitgroup_prog_group_desc.hitgroup.entryFunctionNameAH = fn.getCharPointer().getAddress();
			continue;
		}

		if (fn.startsWith(INTERSECTION_FUNCTION_PREFIX))
		{
			config.desc.hitgroup_prog_group_desc.hitgroup.moduleIS = module->get();
			config.desc.hitgroup_prog_group_desc.hitgroup.entryFunctionNameIS = fn.getCharPointer().getAddress();
			continue;
		}
	}
	ProgramGroupHandle handle = OptiXProgramGroup::create(config.options.program_group_options, config.desc.hitgroup_prog_group_desc);
	handle->makeGroup(context);

	return handle;
}

ModuleHandle OptixEngine::createModule(PtxData& data)
{
	ModuleHandle handle = OptiXModule::create(config.options.pipeline_compile_options, config.options.module_compile_options);
	if (!handle)
		throw std::runtime_error("ModuleHandle creation failed!");

	handle->creatFromPTx(context, data.ptxStr.toStdString());

	return handle;
}

String OptixEngine::extractProgramFunctionName(const String& line, const String& prefix)
{
	String func = line.fromFirstOccurrenceOf(prefix, true, false);

	int leftParan = func.indexOfChar('(');
	if (leftParan == -1) return String::empty;

	return func.substring(0, leftParan);
}

void OptixEngine::createProgramDatabase()
{
	ScopedStopWatch sw(_FN_);

	std::string resourceFolder = properties.renderProps->getVal<std::string>(RenderKey::ResourceFolder);
	File f(resourceFolder);
	if (!f.exists())
		throw std::runtime_error("No resource folder found at " + resourceFolder);

	String ptxFolder = resourceFolder + "/ptx";
	StringArray ptxFiles;
	String wildCard("*.ptx");
	FileServices::getFiles(ptxFolder, ptxFiles, wildCard);

	String ptxStr = String::empty;

	for (auto ptx : ptxFiles)
	{
		File f(ptx);
		if (!f.existsAsFile()) continue;

		String moduleName = f.getFileNameWithoutExtension();
		StringArray functionNames;

		StringArray lines;
		lines.addLines(f.loadFileAsString());

		for (auto line : lines)
		{
			// skip comments
			if (line.startsWith("//")) continue;

			// look for program function names
			for (auto prefix : programPrefixes)
			{
				if (line.contains(prefix))
				{
					String funcName = extractProgramFunctionName(line, prefix);
					if (funcName != String::empty)
					{
						funcName = funcName.trim();
						LOG(DBUG) << funcName;
						functionNames.add(funcName);
					}
					continue;
				}
			}
		}

		if (functionNames.size())
		{
			PtxData data;
			data.ptxStr = lines.joinIntoString("\n");
			data.functionNames = functionNames;
			programDB.insert(std::make_pair(moduleName, data));
		}
	}
}

void OptixEngine::createProgramGoups()
{
	// one module per ptx file 
	for (auto it : programDB)
	{
		// create a module from the Ptx data
		ModuleHandle module = createModule(it.second);

		// iterate throgh the standard program function
		// names prefixes found in this ptx file
		for (auto fnName : it.second.functionNames)
		{
			if (fnName.startsWith(RAYGEN_FUNCTION_PREFIX))
			{
				ProgramGroupHandle raygenHandle = createRaygenPrograms(module, fnName);
				if (raygenHandle)
					config.programs.raygenProgs.push_back(raygenHandle);

				continue;
			}

			if (fnName.startsWith(MISS_FUNCTION_PREFIX))
			{
				ProgramGroupHandle missHandle = createMissPrograms(module, fnName);
				if (missHandle)
					config.programs.missProgs.push_back(missHandle);

				continue;
			}

			// FIXME have to store these and add them after
			if (fnName.startsWith(CLOSEST_HIT_FUNCTION_PREFIX))
			{
				StringArray functionNames;
				functionNames.add(fnName);
				ProgramGroupHandle hitHandle = createHitgroupPrograms(module, functionNames);
				if (hitHandle)
					config.programs.hitgroupProgs.push_back(hitHandle);

				continue;
			}
		}

		// gotta store the module or it goes out
		// of scope and pipeline creation will fail
		modules.push_back(module);
	}
}


PipelineHandle OptixEngine::createPipeline()
{
	createProgramDatabase();
	createProgramGoups();

	std::vector<OptixProgramGroup> programGroups;
	for (auto prog : config.programs.raygenProgs)
		programGroups.push_back(prog->get());

	for (auto prog : config.programs.missProgs)
		programGroups.push_back(prog->get());

	for (auto prog : config.programs.hitgroupProgs)
		programGroups.push_back(prog->get());

	if (!programGroups.size())
		throw std::runtime_error("No program groups avaialble for creating pipeline");

	PipelineHandle handle = OptiXPipeline::create(config.options.pipeline_compile_options, config.options.pipeline_link_options, programGroups);
	handle->link(context);

	return handle;
}