
// This source file was auto-generated by ClassMate++
// Created: 12 Sep 2019 6:29:23 am
// Copyright (c) 2019, HurleyWorks

using sabi::MeshBuffersHandle;
using sabi::Material;
using sabi::VertexMapRef;
using Eigen::Vector3f;

// ctor
OptixMesh::OptixMesh (RenderableNode& node)
	: weakNode(node)
{	
	node->setUserData(this);
}

// dtor
OptixMesh::~OptixMesh ()
{	
	LOG(DBUG) << _FN_;
	try
	{
		asBuffer.free();

		if (deviceBuffer)
			CUDA_CHECK(cudaFree(reinterpret_cast<void*>(deviceBuffer)));
	}
	catch (const std::runtime_error& e)
	{
		LOG(CRITICAL) << e.what();
	}
	catch (...)
	{
		LOG(CRITICAL) << "Caught unknow exception";
	}
}

void OptixMesh::init(ContextHandle& context)
{
	if (weakNode.expired()) return;

	//ScopedStopWatch sw(_FN_);

	// instances use the GAS from their source
	if (weakNode.lock()->isInstance())
	{
		RenderableNode source = weakNode.lock()->getInstancedFrom();
		if (source)
		{
			OptixMesh* const optixMesh = static_cast<OptixMesh*>(source->getUserdata());
			if (optixMesh)
			{
				GAS = optixMesh->getGAS();
			}

			// we want each instance to be able to have it's own unique material
			// so we create a new one here instead of just using the source's material
			//createMaterials(source->getMesh());
		}

		return;
	}

	MeshBuffersHandle& mesh = weakNode.lock()->getMesh();
	if (!mesh)
		throw std::runtime_error(weakNode.lock()->getName() + " has no mesh");

	// pack all the MeshBuffer data into a binary stream
	std::stringstream str;
	mesh->packIntoBinarStream(str);

	// send it to device
	createBuffer(str.str().size(), str.str().c_str());
	int byteStride = 0; // i think this means tightly packed

	// indices were packed first
	MatrixXu tris;
	mesh->getAllSurfaceIndices(tris);

	indices.data = deviceBuffer + byteOffset; 
	indices.byte_stride = static_cast<uint16_t>(byteStride);
	indices.count = static_cast<uint32_t>(tris.size());
	indices.elmt_byte_size = static_cast<uint16_t>(sizeof(uint32_t));

	byteOffset +=  tris.size() * sizeof(uint32_t);
	
	// vertices 
	positions.data = deviceBuffer + byteOffset; 
	positions.byte_stride = static_cast<uint16_t>(byteStride);
	positions.count = static_cast<uint32_t>(mesh->V.cols());
	positions.elmt_byte_size = static_cast<uint16_t>(sizeof(float));

	byteOffset += mesh->V.size() * sizeof(float);

	// vertex normals 
	normals.data = deviceBuffer + byteOffset; 
	normals.byte_stride = static_cast<uint16_t>(byteStride);
	normals.count = static_cast<uint32_t>(mesh->N.cols());
	normals.elmt_byte_size = static_cast<uint16_t>(sizeof(float));

	byteOffset += mesh->N.size() * sizeof(float);

	
	auto it = mesh->vmaps.find("UV");
	if (it != mesh->vmaps.end())
	{
		VertexMapRef vmap = it->second;

		texcoords.data = deviceBuffer + byteOffset;
		texcoords.byte_stride = static_cast<uint16_t>(byteStride);
		texcoords.count = static_cast<uint32_t>(vmap->values.cols());
		texcoords.elmt_byte_size = static_cast<uint16_t>(sizeof(float));
	}
	

	createGAS(context);

	createMaterials(weakNode.lock()->getMesh());
}

void OptixMesh::createBuffer(const uint64_t buf_size, const void* data)
{
	CUDA_CHECK(cudaMalloc(reinterpret_cast<void**>(&deviceBuffer), buf_size));
	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(deviceBuffer),
		data,
		buf_size,
		cudaMemcpyHostToDevice
	));	
}

void OptixMesh::createGAS(ContextHandle& context)
{
	uint32_t triangle_input_flags = OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT;

	OptixBuildInput triangle_input;
	memset(&triangle_input, 0, sizeof(OptixBuildInput));

	triangle_input.type = OPTIX_BUILD_INPUT_TYPE_TRIANGLES;
	triangle_input.triangleArray.vertexFormat = OPTIX_VERTEX_FORMAT_FLOAT3;
	triangle_input.triangleArray.vertexStrideInBytes =
		positions.byte_stride ?
		positions.byte_stride :
		sizeof(float3),
		triangle_input.triangleArray.numVertices = positions.count;
	triangle_input.triangleArray.vertexBuffers = &(positions.data);
	triangle_input.triangleArray.indexFormat =
		indices.elmt_byte_size == 2 ?
		OPTIX_INDICES_FORMAT_UNSIGNED_SHORT3 :
		OPTIX_INDICES_FORMAT_UNSIGNED_INT3;
	triangle_input.triangleArray.indexStrideInBytes =
		indices.byte_stride ?
		indices.byte_stride :
		indices.elmt_byte_size * 3;
	triangle_input.triangleArray.numIndexTriplets = indices.count / 3;
	triangle_input.triangleArray.indexBuffer = indices.data;
	triangle_input.triangleArray.flags = &triangle_input_flags;
	triangle_input.triangleArray.numSbtRecords = 1;

	// from Ingo Wald tutorial

	// BLAS setup

	OptixAccelBuildOptions accelOptions = {};
	accelOptions.buildFlags = OPTIX_BUILD_FLAG_NONE
		| OPTIX_BUILD_FLAG_ALLOW_COMPACTION
		;
	accelOptions.motionOptions.numKeys = 1;
	accelOptions.operation = OPTIX_BUILD_OPERATION_BUILD;

	OptixAccelBufferSizes blasBufferSizes;
	OPTIX_CHECK(optixAccelComputeMemoryUsage
	(	context->get(),
		&accelOptions,
		&triangle_input,
		1,  // num_build_inputs
		&blasBufferSizes
	));

	// prepare compaction
	
	CUDABuffer compactedSizeBuffer;
	compactedSizeBuffer.alloc(sizeof(uint64_t));

	OptixAccelEmitDesc emitDesc;
	emitDesc.type = OPTIX_PROPERTY_TYPE_COMPACTED_SIZE;
	emitDesc.result = compactedSizeBuffer.d_pointer();

	// execute build (main stage)

	CUDABuffer tempBuffer;
	tempBuffer.alloc(blasBufferSizes.tempSizeInBytes);

	CUDABuffer outputBuffer;
	outputBuffer.alloc(blasBufferSizes.outputSizeInBytes);

	OPTIX_CHECK(optixAccelBuild(context->get(),
		/* stream */0,
		&accelOptions,
		&triangle_input,
		1,
		tempBuffer.d_pointer(),
		tempBuffer.sizeInBytes,

		outputBuffer.d_pointer(),
		outputBuffer.sizeInBytes,

		&GAS,

		&emitDesc, 1
	));
	CUDA_SYNC_CHECK();

	// perform compaction

	uint64_t compactedSize;
	compactedSizeBuffer.download(&compactedSize, 1);

	asBuffer.alloc(compactedSize);
	OPTIX_CHECK(optixAccelCompact(context->get(),
		/*stream:*/0,
		GAS,
		asBuffer.d_pointer(),
		asBuffer.sizeInBytes,
		&GAS));
	CUDA_SYNC_CHECK();

	// clean up
	outputBuffer.free(); // << the UNcompacted, temporary output buffer
	tempBuffer.free();
	compactedSizeBuffer.free();
}

void OptixMesh::createMaterials(MeshBuffersHandle& mesh)
{

	for (auto s : mesh->S)
	{
		const Material& m = s.getMaterial();
		OptixMaterialData::Pbr mtl;
		mtl.base_color = make_float4(m.base_color.x(), m.base_color.y(), m.base_color.z(), m.base_color.w());
		mtl.metallic = m.metallic;
		mtl.roughness = m.roughness;

		if (m.base_color_tex)
		{
			for (auto image : m.base_color_tex->getImages())
			{
				ImageInfo& spec = image->spec;
				addImage(spec.width, spec.height, 8, spec.channels, static_cast<void*>(image->uint8Pixels.data()));
			}

			for (auto& s : m.base_color_tex->getSamplers())
			{
				addSampler(static_cast<cudaTextureAddressMode>(s.wrapS),
						   static_cast<cudaTextureAddressMode>(s.wrapT),
					       static_cast<cudaTextureFilterMode>(s.filter), s.imageIndex);

				mtl.base_color_tex = samplers.back();
			}
			
		}

		if (m.metallic_roughness_tex)
		{
			for (auto image : m.metallic_roughness_tex->getImages())
			{
				ImageInfo& spec = image->spec;
				addImage(spec.width, spec.height, 8, spec.channels, static_cast<void*>(image->uint8Pixels.data()));
			}

			for (auto& s : m.metallic_roughness_tex->getSamplers())
			{
				addSampler(static_cast<cudaTextureAddressMode>(s.wrapS),
					static_cast<cudaTextureAddressMode>(s.wrapT),
					static_cast<cudaTextureFilterMode>(s.filter), s.imageIndex);
			}
			
			mtl.metallic_roughness_tex = samplers.back();
		}

		if (m.normal_tex)
		{
			for (auto image : m.normal_tex->getImages())
			{
				ImageInfo& spec = image->spec;
				addImage(spec.width, spec.height, 8, spec.channels, static_cast<void*>(image->uint8Pixels.data()));
			}

			for (auto& s : m.normal_tex->getSamplers())
			{
				addSampler(static_cast<cudaTextureAddressMode>(s.wrapS),
					static_cast<cudaTextureAddressMode>(s.wrapT),
					static_cast<cudaTextureFilterMode>(s.filter), s.imageIndex);
			}
			
			mtl.normal_tex = samplers.back();
		}

		materials.push_back(mtl);
		
	}
}

void OptixMesh::addImage(const int32_t width, const int32_t height, const int32_t bits_per_component, const int32_t num_components, const void* data)
{
	// Allocate CUDA array in device memory
	int32_t               pitch;
	cudaChannelFormatDesc channel_desc;
	if (bits_per_component == 8)
	{
		pitch = width * num_components * sizeof(uint8_t);
		channel_desc = cudaCreateChannelDesc<uchar4>();
	}
	else if (bits_per_component == 16)
	{
		pitch = width * num_components * sizeof(uint16_t);
		channel_desc = cudaCreateChannelDesc<uchar4>();
	}
	else
	{
		throw Exception("Unsupported bits/component in glTF image");
	}


	cudaArray_t   cuda_array = nullptr;
	CUDA_CHECK(cudaMallocArray(
		&cuda_array,
		&channel_desc,
		width,
		height
	));
	CUDA_CHECK(cudaMemcpy2DToArray(
		cuda_array,
		0,     // X offset
		0,     // Y offset
		data,
		pitch,
		pitch,
		height,
		cudaMemcpyHostToDevice
	));
	images.push_back(cuda_array);
}

void OptixMesh::addSampler(cudaTextureAddressMode address_s, cudaTextureAddressMode address_t, cudaTextureFilterMode filter_mode, const int32_t image_idx)
{
	cudaResourceDesc res_desc = {};
	res_desc.resType = cudaResourceTypeArray;
	if (images.size() && image_idx >= 0 && image_idx < images.size())
	{
		res_desc.res.array.array = images[image_idx];
	}
	else
	{
		throw std::runtime_error("Invalid image index in Sampler .... can't create OptixMesh for " + weakNode.lock()->getName());
	}
		
	cudaTextureDesc tex_desc = {};
	tex_desc.addressMode[0] = address_s;
	tex_desc.addressMode[1] = address_t;
	tex_desc.filterMode = filter_mode;
	tex_desc.readMode = cudaReadModeNormalizedFloat;
	tex_desc.normalizedCoords = 1;
	tex_desc.maxAnisotropy = 1;
	tex_desc.maxMipmapLevelClamp = 99;
	tex_desc.minMipmapLevelClamp = 0;
	tex_desc.mipmapFilterMode = cudaFilterModePoint;
	tex_desc.borderColor[0] = 1.0f;
	tex_desc.sRGB = 0; // TODO: glTF assumes sRGB for base_color -- handle in shader

	// Create texture object
	cudaTextureObject_t cuda_tex = 0;
	CUDA_CHECK(cudaCreateTextureObject(&cuda_tex, &res_desc, &tex_desc, nullptr));
	samplers.push_back(cuda_tex);
}

