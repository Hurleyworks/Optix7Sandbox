
// This source file was auto-generated by ClassMate++
// Created: 12 Sep 2019 6:29:23 am
// Copyright (c) 2019, HurleyWorks

using sabi::MeshBuffersHandle;
using Eigen::Vector3f;

// ctor
OptixMesh::OptixMesh (RenderableNode& node)
	: weakNode(node)
{	
	node->setUserData(this);
}

// dtor
OptixMesh::~OptixMesh ()
{	
	LOG(DBUG) << _FN_;
	try
	{
		asBuffer.free();

		if (deviceBuffer)
			CUDA_CHECK(cudaFree(reinterpret_cast<void*>(deviceBuffer)));
	}
	catch (const std::runtime_error& e)
	{
		LOG(CRITICAL) << e.what();
	}
	catch (...)
	{
		LOG(CRITICAL) << "Caught unknow exception";
	}
}

void OptixMesh::init(ContextHandle& context)
{
	if (weakNode.expired()) return;

	ScopedStopWatch sw(_FN_);

	// instances use the GAS from their source
	if (weakNode.lock()->isInstance())
	{
		RenderableNode source = weakNode.lock()->getInstancedFrom();
		if (source)
		{
			OptixMesh* const optixMesh = static_cast<OptixMesh*>(source->getUserdata());
			if (optixMesh)
			{
				GAS = optixMesh->getGAS();
			}
		}

		return;
	}

	MeshBuffersHandle& mesh = weakNode.lock()->getMesh();
	if (!mesh)
		throw std::runtime_error(weakNode.lock()->getName() + " has no mesh");

	// pack all the MeshBuffer data into a binary stream
	std::stringstream str;
	mesh->packIntoBinarStream(str);

	// send it to device
	createBuffer(str.str().size(), str.str().c_str());
	int byteStride = 0; // i think this means tightly packed

	// indices were packed first
	MatrixXu tris;
	mesh->getAllSurfaceIndices(tris);

	indices.data = deviceBuffer + byteOffset; 
	indices.byte_stride = static_cast<uint16_t>(byteStride);
	indices.count = static_cast<uint32_t>(tris.size());
	indices.elmt_byte_size = static_cast<uint16_t>(sizeof(uint32_t));

	byteOffset +=  tris.size() * sizeof(uint32_t);
	
	// vertices 
	positions.data = deviceBuffer + byteOffset; 
	positions.byte_stride = static_cast<uint16_t>(byteStride);
	positions.count = static_cast<uint32_t>(mesh->V.cols());
	positions.elmt_byte_size = static_cast<uint16_t>(sizeof(float));

	byteOffset += mesh->V.size() * sizeof(float);

	// vertex normals 
	normals.data = deviceBuffer + byteOffset; 
	normals.byte_stride = static_cast<uint16_t>(byteStride);
	normals.count = static_cast<uint32_t>(mesh->N.cols());
	normals.elmt_byte_size = static_cast<uint16_t>(sizeof(float));

	byteOffset += mesh->N.size() * sizeof(float);

	createGAS(context);
}

void OptixMesh::createBuffer(const uint64_t buf_size, const void* data)
{
	CUDA_CHECK(cudaMalloc(reinterpret_cast<void**>(&deviceBuffer), buf_size));
	CUDA_CHECK(cudaMemcpy(
		reinterpret_cast<void*>(deviceBuffer),
		data,
		buf_size,
		cudaMemcpyHostToDevice
	));	
}

void OptixMesh::createGAS(ContextHandle& context)
{
	uint32_t triangle_input_flags = OPTIX_GEOMETRY_FLAG_DISABLE_ANYHIT;

	OptixBuildInput triangle_input;
	memset(&triangle_input, 0, sizeof(OptixBuildInput));

	triangle_input.type = OPTIX_BUILD_INPUT_TYPE_TRIANGLES;
	triangle_input.triangleArray.vertexFormat = OPTIX_VERTEX_FORMAT_FLOAT3;
	triangle_input.triangleArray.vertexStrideInBytes =
		positions.byte_stride ?
		positions.byte_stride :
		sizeof(float3),
		triangle_input.triangleArray.numVertices = positions.count;
	triangle_input.triangleArray.vertexBuffers = &(positions.data);
	triangle_input.triangleArray.indexFormat =
		indices.elmt_byte_size == 2 ?
		OPTIX_INDICES_FORMAT_UNSIGNED_SHORT3 :
		OPTIX_INDICES_FORMAT_UNSIGNED_INT3;
	triangle_input.triangleArray.indexStrideInBytes =
		indices.byte_stride ?
		indices.byte_stride :
		indices.elmt_byte_size * 3;
	triangle_input.triangleArray.numIndexTriplets = indices.count / 3;
	triangle_input.triangleArray.indexBuffer = indices.data;
	triangle_input.triangleArray.flags = &triangle_input_flags;
	triangle_input.triangleArray.numSbtRecords = 1;

	// from Ingo Wald tutorial

	// BLAS setup

	OptixAccelBuildOptions accelOptions = {};
	accelOptions.buildFlags = OPTIX_BUILD_FLAG_NONE
		| OPTIX_BUILD_FLAG_ALLOW_COMPACTION
		;
	accelOptions.motionOptions.numKeys = 1;
	accelOptions.operation = OPTIX_BUILD_OPERATION_BUILD;

	OptixAccelBufferSizes blasBufferSizes;
	OPTIX_CHECK(optixAccelComputeMemoryUsage
	(	context->get(),
		&accelOptions,
		&triangle_input,
		1,  // num_build_inputs
		&blasBufferSizes
	));

	// prepare compaction
	
	CUDABuffer compactedSizeBuffer;
	compactedSizeBuffer.alloc(sizeof(uint64_t));

	OptixAccelEmitDesc emitDesc;
	emitDesc.type = OPTIX_PROPERTY_TYPE_COMPACTED_SIZE;
	emitDesc.result = compactedSizeBuffer.d_pointer();

	// execute build (main stage)

	CUDABuffer tempBuffer;
	tempBuffer.alloc(blasBufferSizes.tempSizeInBytes);

	CUDABuffer outputBuffer;
	outputBuffer.alloc(blasBufferSizes.outputSizeInBytes);

	OPTIX_CHECK(optixAccelBuild(context->get(),
		/* stream */0,
		&accelOptions,
		&triangle_input,
		1,
		tempBuffer.d_pointer(),
		tempBuffer.sizeInBytes,

		outputBuffer.d_pointer(),
		outputBuffer.sizeInBytes,

		&GAS,

		&emitDesc, 1
	));
	CUDA_SYNC_CHECK();

	// perform compaction

	uint64_t compactedSize;
	compactedSizeBuffer.download(&compactedSize, 1);

	asBuffer.alloc(compactedSize);
	OPTIX_CHECK(optixAccelCompact(context->get(),
		/*stream:*/0,
		GAS,
		asBuffer.d_pointer(),
		asBuffer.sizeInBytes,
		&GAS));
	CUDA_SYNC_CHECK();

	// clean up
	outputBuffer.free(); // << the UNcompacted, temporary output buffer
	tempBuffer.free();
	compactedSizeBuffer.free();
}

